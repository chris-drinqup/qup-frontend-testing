<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUP Barista Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-dark: #4c63d2;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a3e;
            --bg-card: #262654;
            --text-primary: #ffffff;
            --text-secondary: #a5a5c9;
            --border: #3a3a6b;
            --shadow: rgba(0, 0, 0, 0.4);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .login-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            backdrop-filter: blur(2px);
        }

        .login-form {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            padding: 50px;
            border-radius: 25px;
            width: 450px;
            box-shadow: 0 15px 40px var(--shadow);
            text-align: center;
            border: 1px solid var(--border);
            position: relative;
            transform: translateY(0);
            transition: transform 0.3s ease;
        }

        .login-form:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 60px var(--shadow);
        }

        .login-form h2 {
            color: var(--text-primary);
            margin-bottom: 35px;
            font-size: 32px;
            font-weight: 800;
            letter-spacing: -0.5px;
        }

        .form-group {
            margin-bottom: 25px;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input {
            width: 100%;
            padding: 16px 20px;
            border: 2px solid var(--border);
            border-radius: 15px;
            font-size: 16px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--bg-card);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .login-btn {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 700;
            font-size: 16px;
            width: 100%;
            margin-top: 15px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .dashboard-container {
            display: none;
            margin: 20px;
            min-height: calc(100vh - 40px);
        }

        .container {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 40px;
            box-shadow: 0 15px 40px var(--shadow);
            max-width: 1400px;
            margin: 0 auto;
            border: 1px solid var(--border);
            position: relative;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border);
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 20px;
            margin: -10px -10px 30px -10px;
        }

        h2 {
            color: var(--text-primary);
            margin: 0;
            font-size: 32px;
            font-weight: 800;
            letter-spacing: -0.5px;
        }

        .logout-btn {
            background: linear-gradient(45deg, var(--danger), #dc2626);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }

        .datetime-container {
            font-size: 18px;
            margin-bottom: 25px;
            color: var(--text-primary);
            font-weight: 700;
            padding: 25px 30px;
            background: var(--bg-secondary);
            border-radius: 18px;
            border: 1px solid var(--border);
            box-shadow: 0 8px 25px var(--shadow);
            backdrop-filter: blur(10px);
        }

        .status-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .refresh-btn, .debug-btn, .mass-action-btn, .danger-btn {
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        .refresh-btn {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 50%, #2e7d32 100%);
        }

        .debug-btn {
            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 50%, #6a1b9a 100%);
        }

        .mass-action-btn {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 50%, #ef6c00 100%);
        }

        .danger-btn {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 50%, #b71c1c 100%);
        }

        .refresh-btn:hover, .debug-btn:hover, .mass-action-btn:hover, .danger-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 24px rgba(0,0,0,0.4);
        }

        .websocket-status {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            margin-left: 15px;
        }

        .websocket-status.connected {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .websocket-status.disconnected {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .websocket-status.connecting {
            background: rgba(251, 191, 36, 0.2);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        .current-order-section {
            background: var(--bg-secondary);
            border-radius: 20px;
            padding: 30px;
            margin-bottom: 30px;
            border: 2px solid var(--primary);
        }

        .current-order-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 20px;
            text-align: center;
        }

        .order-card {
            background: var(--bg-card);
            border-radius: 15px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid var(--border);
            box-shadow: 0 8px 20px var(--shadow);
        }

        .order-card.ready {
            border-color: var(--success);
            background: linear-gradient(135deg, var(--bg-card) 0%, rgba(16, 185, 129, 0.1) 100%);
        }

        .order-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .customer-name {
            font-size: 18px;
            font-weight: 700;
            color: var(--text-primary);
        }

        .order-time {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #1976d2;
            animation: pulse 2s infinite;
        }

        .order-description {
            font-size: 16px;
            color: var(--text-secondary);
            margin-bottom: 15px;
            line-height: 1.4;
        }

        .pickup-code-display {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #059669;
            background: rgba(209, 250, 229, 0.8);
            padding: 12px 16px;
            border-radius: 10px;
            border: 1px solid rgba(5, 150, 105, 0.2);
            display: inline-block;
            margin-bottom: 15px;
            font-size: 18px;
        }

        .order-actions {
            display: flex;
            gap: 10px;
            justify-content: center;
        }

        .action-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
        }

        .action-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-finalize {
            background: linear-gradient(45deg, var(--info), #1976d2);
            color: white;
        }

        .btn-complete {
            background: linear-gradient(45deg, var(--success), #059669);
            color: white;
        }

        .btn-cancel {
            background: linear-gradient(45deg, var(--danger), #dc2626);
            color: white;
        }

        .no-orders {
            text-align: center;
            color: var(--text-secondary);
            font-style: italic;
            padding: 40px;
            font-size: 18px;
        }

        .order-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
            z-index: 1000;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s ease;
        }

        .order-notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .error-message {
            background: rgba(239, 68, 68, 0.15);
            color: var(--danger);
            padding: 18px 25px;
            margin: 15px 0;
            border-radius: 15px;
            border: 1px solid var(--danger);
            font-weight: 600;
            backdrop-filter: blur(10px);
            display: none;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 25px;
                border-radius: 20px;
            }

            .login-form {
                width: 90%;
                padding: 35px;
                border-radius: 20px;
            }

            .datetime-container {
                font-size: 16px;
                padding: 20px;
            }

            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            h2 {
                font-size: 28px;
            }

            .status-buttons {
                justify-content: center;
            }

            .order-header {
                flex-direction: column;
                gap: 10px;
                text-align: center;
            }

            .order-actions {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div class="login-container" id="loginContainer">
        <div class="login-form">
            <h2>QUP Barista Dashboard</h2>
            <div class="form-group">
                <label for="email">Email:</label>
                <input type="email" id="email" placeholder="Enter your email">
            </div>
            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" placeholder="Enter your password">
            </div>
            <button class="login-btn" id="loginButton">
                <span id="loginText">Sign In</span>
                <div id="loginLoading" class="loading" style="display: none;"></div>
            </button>
            <div id="loginError" class="error-message"></div>
        </div>
    </div>

    <!-- Dashboard -->
    <div class="dashboard-container" id="dashboardContainer">
        <div class="container">
            <div class="header">
                <h2>QUP Barista</h2>
                <div style="display: flex; align-items: center;">
                    <span id="userInfo" class="user-info"></span>
                    <span id="websocketStatus" class="websocket-status disconnected">Real-time: OFF</span>
                    <button class="logout-btn" onclick="logout()">Sign Out</button>
                </div>
            </div>

            <div id="errorNotification" class="error-message"></div>

            <div class="datetime-container">
                <span id="localDateTime"></span> â€¢ <span id="queueCounter">0 orders</span> active
                <span id="websocketStatus2" class="websocket-status disconnected">WebSocket: Disconnected</span>

                <div class="status-buttons">
                    <button class="refresh-btn" onclick="fetchQueue()">Manual Refresh</button>
                    <button class="debug-btn" onclick="debugSystem()">Debug System</button>
                    <button class="mass-action-btn" onclick="finalizeAllOrders()">Finalize All</button>
                    <button class="mass-action-btn" onclick="completeAllOrders()">Complete All</button>
                    <button class="danger-btn" onclick="clearAllOrders()">Clear All</button>
                </div>
            </div>

            <div class="current-order-section">
                <div class="current-order-title">Current Orders</div>
                <div id="ordersContainer">
                    <div class="no-orders">Connecting to real-time updates...</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = 'https://qupcore-supercode-692478335867.us-central1.run.app';
        const SUPABASE_URL = 'https://eorhgophbjjbiguvkygo.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVvcmhnb3BoYmpqYmlndXZreWdvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg4MjMyMjUsImV4cCI6MjA2NDM5OTIyNX0.fV_6TFXfjDVusTeknF_LAGjxw7BfTZtoQ0helbm5mwo';

        // Initialize Supabase
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Global state
        let socket = null;
        let currentUser = null;
        let developerKey = null;
        let dateTimeInterval = null;
        let liveTimerInterval = null;
        let isActionInProgress = false;
        let autoRefreshInterval = null;

        // Check if user is already logged in
        async function init() {
            console.log('QUP Barista Dashboard initializing...');

            try {
                const { data: { user } } = await supabase.auth.getUser();
                if (user) {
                    showUserInfo(user);
                    showDashboard(user);
                } else {
                    showLogin();
                }
            } catch (error) {
                console.error('Initialization error:', error);
                showLogin();
            }

            // Add event listener for login button
            document.getElementById('loginButton').addEventListener('click', handleLogin);
        }

        function showUserInfo(user) {
            const userInfoSpan = document.getElementById('userInfo');
            if (userInfoSpan) {
                userInfoSpan.textContent = user.email;
                userInfoSpan.style.display = 'inline';
            }
        }

        // Authentication
        async function handleLogin() {
            const email = document.getElementById('email').value.trim();
            const password = document.getElementById('password').value.trim();

            if (!email || !password) {
                showError('Please enter both email and password');
                return;
            }

            setLoading(true);

            try {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: email,
                    password: password
                });

                if (error) throw error;

                console.log('Supabase login successful');
                showUserInfo(data.user);
                showDashboard(data.user);

            } catch (error) {
                console.error('Login failed:', error);
                showError('Login failed: ' + error.message);
            } finally {
                setLoading(false);
            }
        }

        async function logout() {
            try {
                await supabase.auth.signOut();

                // Cleanup
                if (socket) {
                    socket.disconnect();
                    socket = null;
                }
                stopAllIntervals();

                currentUser = null;
                developerKey = null;

                // Clear form fields
                document.getElementById('email').value = '';
                document.getElementById('password').value = '';

                showLogin();

            } catch (error) {
                console.error('Logout failed:', error);
            }
        }

        function showLogin() {
            document.getElementById('loginContainer').style.display = 'flex';
            document.getElementById('dashboardContainer').style.display = 'none';
        }

        async function showDashboard(user) {
            currentUser = user;

            document.getElementById('loginContainer').style.display = 'none';
            document.getElementById('dashboardContainer').style.display = 'block';

            // Get developer key for API access
            await getDeveloperKey();

            // Connect WebSocket
            connectWebSocket();

            // Start updates
            startTimeUpdates();
            fetchQueue();
            startAutoRefresh();

            console.log('Dashboard initialized for:', user.email);
        }

        // Get developer key for API access
        async function getDeveloperKey() {
            try {
                console.log('Getting developer key...');

                const response = await fetch(`${API_BASE}/api/auth/developer/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: 'developer',
                        password: 'dev123'
                    })
                });

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();

                if (data.developer_key) {
                    developerKey = data.developer_key;
                    console.log('Developer key obtained');
                } else {
                    throw new Error(data.error || 'No developer key in response');
                }
            } catch (error) {
                console.error('Developer key error:', error);

                // Fallback to hardcoded key
                console.log('Using fallback developer key...');
                developerKey = 'UwCNmn3I0XxmJ15nRxu6dkPIqAz46dxOb4ljz0-SRlc';
                console.log('Using fallback developer key');
            }
        }

        // WebSocket connection
        function connectWebSocket() {
            try {
                console.log('Connecting to WebSocket...');

                socket = io(API_BASE, {
                    transports: ['websocket', 'polling'],
                    timeout: 20000,
                    reconnection: true,
                    reconnectionDelay: 2000,
                    reconnectionAttempts: 5,
                    forceNew: true
                });

                socket.on('connect', () => {
                    updateWebSocketStatus('connected');
                    console.log('WebSocket connected');

                    // Subscribe to barista events
                    socket.emit('subscribe_barista', { barista: currentUser.email });
                });

                socket.on('disconnect', () => {
                    updateWebSocketStatus('disconnected');
                    console.log('WebSocket disconnected');
                });

                socket.on('connect_error', (error) => {
                    console.error('WebSocket connection error:', error);
                    updateWebSocketStatus('disconnected');
                });

                socket.on('order_update', (data) => {
                    console.log('Order update received:', data);
                    handleOrderUpdate(data);
                });

                socket.on('order_created', (data) => {
                    console.log('New order created:', data);
                    showOrderNotification(`New order: ${data.orderId}`);
                    // Fetch fresh queue data
                    setTimeout(fetchQueue, 500);
                });

                socket.on('queue_update', (data) => {
                    console.log('Queue update received:', data);
                    if (data.queue) {
                        updateOrdersDisplay(data.queue);
                    }
                });

                updateWebSocketStatus('connecting');

            } catch (error) {
                console.error('WebSocket initialization failed:', error);
                updateWebSocketStatus('disconnected');
            }
        }

        function updateWebSocketStatus(status) {
            const statusElements = [
                document.getElementById('websocketStatus'),
                document.getElementById('websocketStatus2')
            ];

            statusElements.forEach(element => {
                if (element) {
                    element.className = `websocket-status ${status}`;
                    switch (status) {
                        case 'connected':
                            element.textContent = 'Real-time: ON';
                            break;
                        case 'connecting':
                            element.textContent = 'Real-time: Connecting...';
                            break;
                        case 'disconnected':
                            element.textContent = 'Real-time: OFF';
                            break;
                    }
                }
            });
        }

        function handleOrderUpdate(data) {
            console.log('Handling order update:', data.action);

            // Show notification
            showOrderNotification(`Order ${data.orderId}: ${data.action}`);

            // Refresh queue after a short delay
            if (!isActionInProgress) {
                setTimeout(fetchQueue, 1000);
            }
        }

        function showOrderNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'order-notification';
            notification.innerHTML = `<strong>Real-Time Update</strong><br>${message}`;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // API calls
        async function apiCall(endpoint, options = {}) {
            if (!developerKey) {
                throw new Error('Not authenticated - no developer key available');
            }

            const url = `${API_BASE}${endpoint}`;
            const defaultHeaders = {
                "X-API-Key": developerKey,
                "Content-Type": "application/json"
            };

            const finalOptions = {
                ...options,
                headers: { ...defaultHeaders, ...(options.headers || {}) }
            };

            try {
                console.log(`API Call: ${options.method || 'GET'} ${url}`);
                const response = await fetch(url, finalOptions);
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || `HTTP ${response.status}: ${response.statusText}`);
                }

                return data;
            } catch (error) {
                console.error(`API call failed for ${endpoint}:`, error);
                throw error;
            }
        }

        async function fetchQueue() {
            if (!developerKey) {
                console.log('Waiting for authentication...');
                return;
            }

            try {
                console.log('Fetching queue data...');
                const data = await apiCall(`/api/v1/queue/list?admin=true&t=${Date.now()}`);

                if (data.status === "success") {
                    console.log(`Queue fetched: ${data.queue?.length || 0} items`);
                    updateOrdersDisplay(data.queue || []);
                } else {
                    console.error("Queue fetch failed:", data.message);
                    showError("Failed to fetch queue data");
                }
            } catch (error) {
                console.error("Error fetching queue:", error);
                showError(`Queue fetch error: ${error.message}`);
            }
        }

        function updateOrdersDisplay(queue) {
            const container = document.getElementById("ordersContainer");
            if (!container) return;

            // Filter orders: only show the NEXT order to work on (not finalized) AND finalized orders (ready for pickup)
            const filteredOrders = queue.filter(item => !item.cancelled);
            
            // Sort by timestamp to get the order they came in
            filteredOrders.sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
            
            // Get the next order to work on (first non-finalized order)
            const nextOrder = filteredOrders.find(order => !order.finalized);
            
            // Get all finalized orders (ready for pickup)
            const readyOrders = filteredOrders.filter(order => order.finalized);
            
            // Combine: next order + ready orders
            const ordersToShow = [];
            if (nextOrder) ordersToShow.push(nextOrder);
            ordersToShow.push(...readyOrders);

            updateQueueCounter(ordersToShow.length);

            if (ordersToShow.length === 0) {
                container.innerHTML = '<div class="no-orders">No orders to work on</div>';
                return;
            }

            const html = ordersToShow.map((item, index) => {
                const orderDisplay = (item.payload?.order) ? item.payload.order : item.id;
                const customerName = extractCustomerName(item);
                let processingTime = "0:00";
                let pickupCode = "";
                let actions = '';
                let cardClass = 'order-card';
                let statusText = '';

                // Calculate processing time
                if (item.timestamp) {
                    const startTime = new Date(item.timestamp);
                    const now = new Date();
                    const elapsedSeconds = Math.floor((now - startTime) / 1000);
                    processingTime = formatDuration(elapsedSeconds);
                }

                if (item.finalized) {
                    // Order is ready for pickup
                    cardClass += ' ready';
                    statusText = 'Ready for PiQUP';
                    pickupCode = item.pickup_code || generatePickupCode(item.timestamp);
                    actions = `
                        <button class="action-btn btn-complete" onclick="completeOrder('${item.id}')">
                            Complete Pickup
                        </button>
                        <button class="action-btn btn-cancel" onclick="cancelOrder('${item.id}')">
                            Cancel
                        </button>
                    `;
                } else {
                    // Order is next to work on
                    statusText = index === 0 ? 'Next to Prepare' : 'In Queue';
                    actions = `
                        <button class="action-btn btn-finalize" onclick="finalizeOrder('${item.id}')">
                            PiQUP Ready
                        </button>
                        <button class="action-btn btn-cancel" onclick="cancelOrder('${item.id}')">
                            Cancel
                        </button>
                    `;
                }

                return `
                    <div class="${cardClass}" data-order-id="${item.id}" data-start-time="${item.timestamp}">
                        <div class="order-header">
                            <div class="customer-name">${sanitizeHTML(customerName)}</div>
                            <div class="order-time live-timer">${processingTime}</div>
                        </div>
                        <div class="order-description">${sanitizeHTML(orderDisplay)}</div>
                        ${item.finalized ? `<div class="pickup-code-display">Code: ${pickupCode}</div>` : ''}
                        <div style="text-align: center; margin-bottom: 15px; font-weight: 600; color: ${item.finalized ? 'var(--success)' : 'var(--warning)'};">
                            ${statusText}
                        </div>
                        <div class="order-actions">
                            ${actions}
                        </div>
                    </div>
                `;
            }).join('');

            container.innerHTML = html;
        }

        function extractCustomerName(order) {
            // Try to get customer name from email
            if (order.payload?.customer_email) {
                return order.payload.customer_email.split('@')[0];
            }
            
            // Try to get from user_id
            if (order.user_id) {
                return order.user_id.split('@')[0];
            }
            
            // Fallback to order ID
            return order.id.split('_')[0] || 'Customer';
        }

        function updateQueueCounter(count) {
            const counterElement = document.getElementById("queueCounter");
            if (counterElement) {
                counterElement.textContent = `${count} orders`;
            }
        }

        // Order actions
        async function finalizeOrder(orderId) {
            if (isActionInProgress) return;

            isActionInProgress = true;
            console.log(`Finalizing order: ${orderId}`);

            try {
                const pickupCode = generatePickupCode();

                await apiCall("/api/v1/queue/finalize", {
                    method: "POST",
                    body: JSON.stringify({
                        id: orderId,
                        pickup_code: pickupCode
                    })
                });

                console.log(`Order ${orderId} finalized with code: ${pickupCode}`);
                showOrderNotification(`Order finalized! Pickup code: ${pickupCode}`);

                // Notify customers via WebSocket
                if (socket && socket.connected) {
                    socket.emit('order_finalized', {
                        orderId: orderId,
                        pickupCode: pickupCode
                    });
                }

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Error finalizing order:", error);
                showError(`Failed to finalize order: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        async function completeOrder(orderId) {
            if (isActionInProgress) return;

            isActionInProgress = true;
            console.log(`Completing order: ${orderId}`);

            try {
                await apiCall("/api/v1/queue/complete", {
                    method: "POST",
                    body: JSON.stringify({ id: orderId })
                });

                console.log(`Order ${orderId} completed`);
                showOrderNotification(`Order completed: ${orderId}`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Error completing order:", error);
                showError(`Failed to complete order: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        async function cancelOrder(orderId) {
            if (isActionInProgress) return;
            if (!confirm(`Cancel order ${orderId}?`)) return;

            isActionInProgress = true;
            console.log(`Cancelling order: ${orderId}`);

            try {
                await apiCall("/api/v1/queue/cancel", {
                    method: "POST",
                    body: JSON.stringify({ id: orderId })
                });

                console.log(`Order ${orderId} cancelled`);
                showOrderNotification(`Order cancelled: ${orderId}`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Error cancelling order:", error);
                showError(`Failed to cancel order: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        // Mass actions
        async function finalizeAllOrders() {
            if (!confirm("Finalize ALL active orders?")) return;
            if (isActionInProgress) return;

            isActionInProgress = true;
            console.log("Finalizing all orders...");

            try {
                const data = await apiCall("/api/v1/queue/list?admin=true");
                const activeOrders = data.queue.filter(item => !item.finalized && !item.cancelled);

                let successCount = 0;
                for (const order of activeOrders) {
                    try {
                        const pickupCode = generatePickupCode();
                        await apiCall("/api/v1/queue/finalize", {
                            method: "POST",
                            body: JSON.stringify({ id: order.id, pickup_code: pickupCode })
                        });
                        successCount++;
                        await new Promise(resolve => setTimeout(resolve, 200));
                    } catch (error) {
                        console.warn(`Failed to finalize ${order.id}:`, error);
                    }
                }

                showOrderNotification(`Finalized ${successCount}/${activeOrders.length} orders`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Mass finalize failed:", error);
                showError(`Mass finalize failed: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        async function completeAllOrders() {
            if (!confirm("Complete ALL finalized orders?")) return;
            if (isActionInProgress) return;

            isActionInProgress = true;
            console.log("Completing all orders...");

            try {
                const data = await apiCall("/api/v1/queue/list?admin=true");
                const finalizedOrders = data.queue.filter(item => item.finalized && !item.cancelled);

                let successCount = 0;
                for (const order of finalizedOrders) {
                    try {
                        await apiCall("/api/v1/queue/complete", {
                            method: "POST",
                            body: JSON.stringify({ id: order.id })
                        });
                        successCount++;
                        await new Promise(resolve => setTimeout(resolve, 200));
                    } catch (error) {
                        console.warn(`Failed to complete ${order.id}:`, error);
                    }
                }

                showOrderNotification(`Completed ${successCount}/${finalizedOrders.length} orders`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Mass complete failed:", error);
                showError(`Mass complete failed: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        async function clearAllOrders() {
            if (!confirm('Clear all orders? This cannot be undone!')) return;
            if (isActionInProgress) return;

            isActionInProgress = true;
            console.log("Clearing all orders...");

            try {
                const data = await apiCall("/api/v1/queue/list?admin=true");

                let successCount = 0;
                for (const order of data.queue) {
                    try {
                        await apiCall("/api/v1/queue/cancel", {
                            method: "POST",
                            body: JSON.stringify({ id: order.id })
                        });
                        successCount++;
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (error) {
                        console.warn(`Failed to clear ${order.id}:`, error);
                    }
                }

                showOrderNotification(`Cleared ${successCount}/${data.queue.length} orders`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Clear all failed:", error);
                showError(`Clear all failed: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        // Debug functions
        async function debugSystem() {
            console.log("DEBUGGING SYSTEM...");

            try {
                const queueData = await apiCall("/api/v1/queue/list?admin=true");
                console.log(`API Queue: ${queueData.queue?.length || 0} orders`);
                console.log("Queue details:", queueData.queue);

                const wsStatus = socket?.connected ? 'Connected' : 'Disconnected';
                console.log(`WebSocket: ${wsStatus}`);

                alert(`DEBUG RESULTS:\n\nAPI Queue: ${queueData.queue?.length || 0} orders\nWebSocket: ${wsStatus}\nAuth: ${developerKey ? 'OK' : 'MISSING'}\n\nCheck console for detailed logs.`);

            } catch (error) {
                console.error("Debug failed:", error);
                alert(`Debug failed: ${error.message}`);
            }
        }

        // Utility functions
        function generatePickupCode(timestamp) {
            const now = timestamp ? new Date(timestamp).getTime() : Date.now();
            return (now % 10000).toString().padStart(4, '0');
        }

        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function sanitizeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function updateDateTime() {
            const now = new Date();
            const formattedTime = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            const dateTimeElement = document.getElementById("localDateTime");
            if (dateTimeElement) {
                dateTimeElement.textContent = formattedTime;
            }
        }

        function updateLiveTimers() {
            const timerElements = document.querySelectorAll('.live-timer');
            timerElements.forEach(timer => {
                const card = timer.closest('.order-card');
                const startTime = card?.getAttribute('data-start-time');
                if (startTime) {
                    const start = new Date(startTime);
                    const now = new Date();
                    const elapsedSeconds = Math.floor((now - start) / 1000);
                    timer.textContent = formatDuration(elapsedSeconds);
                }
            });
        }

        function startTimeUpdates() {
            stopAllIntervals();
            dateTimeInterval = setInterval(updateDateTime, 1000);
            liveTimerInterval = setInterval(updateLiveTimers, 1000);
        }

        function stopAllIntervals() {
            if (dateTimeInterval) {
                clearInterval(dateTimeInterval);
                dateTimeInterval = null;
            }
            if (liveTimerInterval) {
                clearInterval(liveTimerInterval);
                liveTimerInterval = null;
            }
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }

            // Auto-refresh queue every 5 seconds to catch new orders
            autoRefreshInterval = setInterval(() => {
                if (!isActionInProgress) {
                    fetchQueue();
                }
            }, 5000);
        }

        function setLoading(loading) {
            const text = document.getElementById('loginText');
            const spinner = document.getElementById('loginLoading');
            const button = text.parentElement;

            if (loading) {
                text.style.display = 'none';
                spinner.style.display = 'inline-block';
                button.disabled = true;
            } else {
                text.style.display = 'inline';
                spinner.style.display = 'none';
                button.disabled = false;
            }
        }

        function showError(message) {
            console.error("Error:", message);

            const errorDiv = document.getElementById("errorNotification");
            if (errorDiv) {
                errorDiv.innerHTML = `<strong>Error:</strong> ${message}`;
                errorDiv.style.display = "block";
                setTimeout(() => {
                    errorDiv.style.display = "none";
                }, 8000);
            }

            // Also show in login screen if visible
            const loginError = document.getElementById("loginError");
            if (loginError && document.getElementById('loginContainer').style.display !== 'none') {
                loginError.innerHTML = `<strong>Error:</strong> ${message}`;
                loginError.style.display = "block";
                setTimeout(() => {
                    loginError.style.display = "none";
                }, 5000);
            }
        }

        // Event listeners
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const loginContainer = document.getElementById('loginContainer');
                if (loginContainer && loginContainer.style.display !== 'none') {
                    handleLogin();
                }
            }
        });

        // Initialize the app
        document.addEventListener('DOMContentLoaded', init);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (socket) socket.disconnect();
            stopAllIntervals();
        });
    </script>
</body>
</html>
