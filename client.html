<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUP - Order Here</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-dark: #4c63d2;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a3e;
            --bg-card: #262654;
            --text-primary: #ffffff;
            --text-secondary: #a5a5c9;
            --border: #3a3a6b;
            --shadow: rgba(0, 0, 0, 0.4);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;
        }

        .container {
            width: 100%;
            max-width: 500px;
            padding: 20px;
        }

        .card {
            background: var(--bg-card);
            border-radius: 20px;
            padding: 40px;
            border: 1px solid var(--border);
            backdrop-filter: blur(10px);
            box-shadow: 0 15px 40px var(--shadow);
            text-align: center;
            position: relative;
            z-index: 10;
        }

        .logo-header {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
            margin-bottom: 10px;
        }

        .company-logo {
            height: 50px;
            width: auto;
            border-radius: 8px;
            object-fit: contain;
        }

        .logo {
            font-size: 3rem;
            font-weight: 800;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: var(--text-secondary);
            margin-bottom: 40px;
            font-size: 1.1rem;
        }

        .connection-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            margin-bottom: 30px;
        }

        .connection-status.connected {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .connection-status.disconnected {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .connection-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        .form-group {
            margin-bottom: 25px;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .form-control {
            width: 100%;
            padding: 16px 20px;
            border: 2px solid var(--border);
            border-radius: 12px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            font-size: 1rem;
            transition: all 0.3s ease;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            background: var(--bg-card);
        }

        .btn {
            width: 100%;
            padding: 16px 24px;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 600;
            font-size: 1.1rem;
            transition: all 0.15s ease;
            position: relative;
            overflow: hidden;
            transform: translateY(0);
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:active {
            transform: translateY(2px) scale(0.98);
            transition: all 0.1s ease;
        }

        .btn-primary {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:active {
            transform: translateY(2px) scale(0.98);
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .btn:disabled:hover::before {
            width: 0;
            height: 0;
        }

        .btn:disabled:active {
            transform: none;
            box-shadow: none;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }

        .order-status {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: left;
        }

        .order-status h3 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.3rem;
        }

        .status-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
        }

        .status-item:last-child {
            border-bottom: none;
        }

        .status-label {
            color: var(--text-secondary);
            font-weight: 500;
        }

        .status-value {
            color: var(--text-primary);
            font-weight: 600;
        }

        .alert {
            padding: 15px 20px;
            border-radius: 12px;
            margin: 15px 0;
            font-weight: 600;
        }

        .alert-success {
            background: rgba(16, 185, 129, 0.15);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .alert-error {
            background: rgba(239, 68, 68, 0.15);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .alert-info {
            background: rgba(59, 130, 246, 0.15);
            color: var(--info);
            border: 1px solid var(--info);
        }

        .user-info {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .user-email {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .logout-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.15s ease;
        }

        .logout-btn:hover {
            border-color: var(--danger);
            color: var(--danger);
            transform: translateY(-1px);
        }

        .logout-btn:active {
            transform: translateY(1px);
        }

        .hidden {
            display: none;
        }

        /* Queue Preview Styles */
        .queue-preview {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .queue-preview h4 {
            color: var(--info);
            margin-bottom: 15px;
        }

        .preview-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }

        .preview-stat {
            background: var(--bg-card);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid var(--border);
        }

        .preview-stat .stat-value {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .preview-stat .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-top: 5px;
        }

        /* QUP Toggle Styles */
        .qup-toggle {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            text-align: center;
        }

        .qup-checkbox {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
        }

        .qup-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            accent-color: var(--primary);
        }

        .qup-checkbox label {
            color: var(--text-primary);
            font-weight: 600;
            cursor: pointer;
        }

        /* QUP Controls Styles */
        .qup-controls {
            background: var(--bg-secondary);
            border: 1px solid var(--success);
            border-radius: 15px;
            padding: 25px;
            margin: 20px 0;
            text-align: center;
        }

        .qup-controls h4 {
            color: var(--success);
            margin-bottom: 20px;
        }

        .position-display {
            font-size: 2rem;
            font-weight: 700;
            margin: 20px 0;
            color: var(--text-primary);
        }

        .qup-buttons {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .qup-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: none;
            font-size: 2rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .qup-btn.up {
            background: linear-gradient(45deg, var(--success), #059669);
            color: white;
        }

        .qup-btn.down {
            background: linear-gradient(45deg, var(--warning), #d97706);
            color: white;
        }

        .qup-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.3);
        }

        .qup-btn:active {
            transform: scale(0.95);
        }

        .qup-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
            transform: none;
        }

        .qup-btn:disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .time-savings {
            font-size: 0.9rem;
            color: var(--success);
            margin: 10px 0;
        }

        .countdown {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--warning);
            margin: 10px 0;
        }

        /* Logo Rain Animation System */
        .logo-rain {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 5;
            overflow: hidden;
        }

        .rain-logo {
            position: absolute;
            width: 30px;
            height: 30px;
            opacity: 0.6;
            animation: rainFall linear infinite;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            transform: rotate(15deg);
            z-index: 25;
        }

        @keyframes rainFall {
            from {
                top: -40px;
                transform: rotate(0deg) scale(1);
            }
            50% {
                transform: rotate(180deg) scale(1.2);
            }
            to {
                top: 100vh;
                transform: rotate(360deg) scale(0.8);
            }
        }

        .rain-logo:nth-child(odd) {
            animation-direction: reverse;
        }

        .rain-logo:nth-child(3n) {
            animation-duration: 4s;
        }

        .rain-logo:nth-child(3n+1) {
            animation-duration: 6s;
        }

        .rain-logo:nth-child(3n+2) {
            animation-duration: 5s;
        }

        /* Anti-screenshot measures - Logo overlay */
        .pickup-section-protected {
            position: relative;
        }

        .logo-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 20;
            overflow: hidden;
        }

        .overlay-logo {
            position: absolute;
            width: 12px;
            height: 12px;
            opacity: 1;
            animation: overlayFloat linear infinite;
            pointer-events: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            filter: brightness(0.1) contrast(2) saturate(0);
        }

        @keyframes overlayFloat {
            0% {
                transform: translateX(-20px) translateY(-20px) rotate(0deg) scale(1);
            }
            25% {
                transform: translateX(20px) translateY(-10px) rotate(90deg) scale(1.1);
            }
            50% {
                transform: translateX(10px) translateY(20px) rotate(180deg) scale(0.9);
            }
            75% {
                transform: translateX(-10px) translateY(10px) rotate(270deg) scale(1.05);
            }
            100% {
                transform: translateX(-20px) translateY(-20px) rotate(360deg) scale(1);
            }
        }

        .overlay-logo:nth-child(2n) {
            animation-duration: 3s;
            animation-direction: reverse;
        }

        .overlay-logo:nth-child(3n) {
            animation-duration: 4s;
            animation-delay: -1s;
        }

        .overlay-logo:nth-child(4n) {
            animation-duration: 5s;
            animation-delay: -2s;
        }

        .pickup-code {
            background: linear-gradient(45deg, var(--success), #059669);
            color: white;
            padding: 20px;
            border-radius: 15px;
            font-size: 2rem;
            font-weight: 800;
            letter-spacing: 2px;
            margin: 20px 0;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            z-index: 15;
        }

        .pickup-code:hover {
            transform: scale(1.05);
            box-shadow: 0 12px 35px rgba(16, 185, 129, 0.6);
        }

        .pickup-code:active {
            transform: scale(1.02);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
        }

        .screen-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(16, 185, 129, 0.9);
            z-index: 9999;
            opacity: 0;
            pointer-events: none;
            animation: flashEffect 0.8s ease-in-out;
        }

        @keyframes flashEffect {
            0% { opacity: 0; }
            50% { opacity: 1; }
            100% { opacity: 0; }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }

            .card {
                padding: 30px 25px;
            }

            .logo {
                font-size: 2.5rem;
            }

            .company-logo {
                height: 40px;
            }

            .preview-stats {
                grid-template-columns: 1fr;
            }

            .qup-buttons {
                gap: 15px;
            }

            .qup-btn {
                width: 50px;
                height: 50px;
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Logo Rain Container -->
    <div id="logoRain" class="logo-rain"></div>

    <div class="container">
        <!-- Login Screen -->
        <div id="loginScreen" class="card">
            <div class="logo-header">
                <img id="loginLogo" class="company-logo" src="" alt="Logo" style="display: none;">
                <div class="logo">QUP</div>
            </div>
            <div class="subtitle">Sign in to place your order</div>

            <div class="form-group">
                <label for="email">Email:</label>
                <input type="email" id="email" class="form-control" placeholder="Enter your email">
            </div>

            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" class="form-control" placeholder="Enter your password">
            </div>

            <button class="btn btn-primary" id="loginButton">
                <span id="loginText">Sign In</span>
                <div id="loginLoading" class="loading hidden"></div>
            </button>

            <div id="loginError" class="alert alert-error hidden">
                Login failed. Please check your credentials.
            </div>

            <div style="margin-top: 20px; font-size: 0.9rem; color: var(--text-secondary);">
                Need an account? Contact your administrator.
            </div>
        </div>

        <!-- Main App Screen -->
        <div id="appScreen" class="card hidden">
            <div class="logo-header">
                <img id="appLogo" class="company-logo" src="" alt="Logo" style="display: none;">
                <div class="logo">QUP</div>
            </div>
            <div class="subtitle">Place Your Order</div>

            <div class="user-info">
                <span id="userEmail" class="user-email"></span>
                <button class="logout-btn" id="logoutButton">Sign Out</button>
            </div>

            <div class="connection-status" id="connectionStatus">
                <div class="connection-dot"></div>
                <span>Connecting...</span>
            </div>

            <!-- Queue Preview Section -->
            <div id="queuePreview" class="queue-preview">
                <h4>ðŸ“Š Current Queue Status</h4>
                <div class="preview-stats">
                    <div class="preview-stat">
                        <div class="stat-value" id="previewWaitTime">Loading...</div>
                        <div class="stat-label">Est. Wait Time</div>
                    </div>
                    <div class="preview-stat">
                        <div class="stat-value" id="previewPosition">Loading...</div>
                        <div class="stat-label">Your Position</div>
                    </div>
                </div>
                <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 10px;">
                    This shows where you'll be placed when you order
                </div>
            </div>

            <!-- Order Form -->
            <div id="orderForm">
                <div class="form-group">
                    <label for="customerName">Your Name:</label>
                    <input type="text" id="customerName" class="form-control"
                           placeholder="Enter your name (e.g., John Smith)">
                </div>

                <div class="form-group">
                    <label for="orderDescription">What would you like to order?</label>
                    <input type="text" id="orderDescription" class="form-control"
                           placeholder="e.g., Large coffee with milk, no sugar">
                </div>

                <!-- QUP Toggle -->
                <div id="qupToggle" class="qup-toggle">
                    <h4>ðŸš€ Enhanced Queue Experience</h4>
                    <div class="qup-checkbox">
                        <input type="checkbox" id="enableQup" />
                        <label for="enableQup">Enable QUP Controls (Move up/down in line)</label>
                    </div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 10px;">
                        With QUP enabled, you can adjust your position in line after ordering to reduce wait time.
                    </div>
                    <button class="btn btn-primary" id="saveQupButton" onclick="saveQupSettings()" style="margin-top: 15px; display: none;">
                        Save QUP Settings
                    </button>
                </div>

                <!-- QUP Preview Controls (before ordering) -->
                <div id="qupPreviewControls" class="qup-controls hidden">
                    <h4>ðŸš€ QUP Preview - Try Before You Order!</h4>
                    <div class="position-display">
                        Preview Position: <span id="previewQupPosition">#3</span>
                    </div>
                    <div class="qup-buttons">
                        <button id="previewQupUpBtn" class="qup-btn up" title="Preview move up" onclick="previewQupUp()">+</button>
                        <button id="previewQupDownBtn" class="qup-btn down" title="Preview move down" onclick="previewQupDown()">-</button>
                    </div>
                    <div class="time-savings" id="previewTimeSavings">
                        Potential time saved: 2 minutes
                    </div>
                    <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 15px;">
                        <strong>Preview Mode:</strong> This simulates your total wait time (including your order processing) |
                        <strong>Cost:</strong> 60s per QUP move
                    </div>
                </div>

                <button class="btn btn-primary" id="orderButton">
                    <span id="orderButtonText">Place Order</span>
                    <div id="orderLoading" class="loading hidden"></div>
                </button>
            </div>

            <!-- Order Status -->
            <div id="orderStatus" class="order-status hidden">
                <h3>Your Order</h3>
                <div class="status-item">
                    <span class="status-label">Customer:</span>
                    <span class="status-value" id="orderCustomerName">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Order:</span>
                    <span class="status-value" id="orderDetails">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Status:</span>
                    <span class="status-value" id="orderCurrentStatus">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Position:</span>
                    <span class="status-value" id="orderPosition">-</span>
                </div>
                <div class="status-item">
                    <span class="status-label">Est. Wait:</span>
                    <span class="status-value countdown" id="orderWaitTime">-</span>
                </div>
            </div>

            <!-- QUP Controls (after ordering, when QUP is enabled) -->
            <div id="qupControls" class="qup-controls hidden">
                <h4>ðŸš€ Queue Position Control</h4>
                <div class="position-display">
                    Position: <span id="currentQupPosition">#1</span>
                </div>
                <div class="qup-buttons">
                  <button id="qupUpBtn" class="qup-btn up" title="Move up in line">+</button>
                    <button id="qupDownBtn" class="qup-btn down" title="Move down in line">-</button>
                </div>
                <div class="time-savings" id="timeSavings">
                    Time saved by moving up: 0 minutes
                </div>
                <div style="font-size: 0.9rem; color: var(--text-secondary); margin-top: 15px;">
                    <strong>Pool Time Available:</strong> <span id="poolTimeDisplay">120s</span> |
                    <strong>QUP Cost:</strong> 60s per move
                </div>
            </div>

            <!-- Pickup Code Display with Logo Protection -->
            <div id="pickupSection" class="pickup-section-protected hidden">
                <div class="alert alert-success">
                    Your order is ready for pickup!
                </div>
                <div style="position: relative;">
                    <div class="pickup-code" id="pickupCode" onclick="flashScreen()">----</div>
                    <div id="logoOverlay" class="logo-overlay"></div>
                </div>
                <div style="color: var(--text-secondary); margin-bottom: 20px;">
                    Show this code to the barista
                </div>
            </div>

            <!-- Order Complete -->
            <div id="completeSection" class="hidden">
                <div class="alert alert-success">
                    Order completed! Thank you for using QUP.
                </div>
                <button class="btn btn-primary" id="newOrderButton">
                    Place Another Order
                </button>
            </div>

            <div id="alerts"></div>
        </div>
    </div>

    <script>
        // Default logo URL constant
        const DEFAULT_LOGO_URL = 'https://eorhgophbjjbiguvkygo.supabase.co/storage/v1/object/public/company-assets/logos/logo-1749419576950.png';

        // Configuration
        let SUPABASE_URL = '';
        let SUPABASE_ANON_KEY = '';
        let API_BASE = 'https://qupcore-supercode-modular-692478335867.us-central1.run.app';

        // Initialize Supabase
        let supabase = null;

        // Global state
        let socket = null;
        let currentUser = null;
        let currentOrder = null;
        let currentOrderData = null;
        let developerKey = null;
        let waitTimeInterval = null;
        let estimatedCompletionTime = null;
        let orderStatusInterval = null;
        let logoRainInterval = null;
        let logoOverlayInterval = null;
        let currentLogo = null;
        let logoSettings = null;
        let qupEnabled = false;
        let currentPosition = 1;
        let previewQupPosition = 3; // Start at estimated position from queue preview
        let orderSubmitting = false; // Prevent multiple submissions

        // Handle QUP checkbox change
        function handleQupToggle() {
            const checkbox = document.getElementById('enableQup');
            const saveButton = document.getElementById('saveQupButton');

            if (checkbox.checked) {
                saveButton.style.display = 'block';
            } else {
                saveButton.style.display = 'none';
                hideElement('qupPreviewControls');
            }
        }

        // Save QUP settings and show preview
        function saveQupSettings() {
            qupEnabled = document.getElementById('enableQup').checked;

            if (qupEnabled) {
                // Get current queue position from preview
                const previewPositionText = document.getElementById('previewPosition').textContent;
                const positionMatch = previewPositionText.match(/\d+/);
                previewQupPosition = positionMatch ? parseInt(positionMatch[0]) - 1 : 2; // Convert to 0-based

                showElement('qupPreviewControls');
                updateQupPreview();
                showAlert('QUP controls enabled! Try the preview buttons above.', 'success');

                // Hide the save button
                document.getElementById('saveQupButton').style.display = 'none';
            }
        }

        // Update QUP preview display
        function updateQupPreview() {
            document.getElementById('previewQupPosition').textContent = '#' + (previewQupPosition + 1);
            updatePreviewQupButtons();
            updatePreviewTimeSavings();
        }

        // Enhanced updatePreviewQupButtons with feasibility-based disabling
        function updatePreviewQupButtons() {
            const upBtn = document.getElementById('previewQupUpBtn');
            const downBtn = document.getElementById('previewQupDownBtn');

            // Basic position limits
            upBtn.disabled = previewQupPosition <= 0;
            downBtn.disabled = previewQupPosition >= 10; // Reasonable limit
            
            // The feasibility check will be done in updatePreviewWaitTime()
            // and will disable the up button if position is not reachable
        }

        // Update preview time savings
        function updatePreviewTimeSavings() {
            const baseTimePerPosition = 60; // 1 minute per position
            const originalPosition = parseInt(document.getElementById('previewPosition').textContent.match(/\d+/)[0]) - 1;
            const timeSaved = Math.max(0, (originalPosition - previewQupPosition) * baseTimePerPosition);
            const minutes = Math.floor(timeSaved / 60);

            document.getElementById('previewTimeSavings').textContent =
                'Potential time saved: ' + minutes + ' minute' + (minutes !== 1 ? 's' : '');
        }

        // Enhanced updatePreviewWaitTime function with real backend data
        async function updatePreviewWaitTime() {
            if (!developerKey) {
                console.warn('No API key available for live queue data');
                calculatePreviewWaitTimeFromEstimate();
                return;
            }

            try {
                // Use actual queue list endpoint to get live data
                const response = await fetch(API_BASE + '/api/v1/queue/list', {
                    headers: { 'X-API-Key': developerKey }
                });

                if (response.ok) {
                    const queueData = await response.json();
                    calculatePreviewWaitTimeFromQueue(queueData);
                } else {
                    console.error('Failed to get queue data:', response.status);
                    calculatePreviewWaitTimeFromEstimate();
                }
            } catch (error) {
                console.error('Failed to get live queue data for preview:', error);
                calculatePreviewWaitTimeFromEstimate();
            }
        }

        // Enhanced calculatePreviewWaitTimeFromQueue with REAL feasibility checking
        function calculatePreviewWaitTimeFromQueue(queueData) {
            try {
                const queue = queueData.queue || [];
                const timeStats = queueData.enhanced_time_management || {};

                // Get actual pool time and QUP cost from backend
                const availablePoolTime = timeStats.available_pool_time || 0;
                const qupCostPerMove = timeStats.current_qup_cost || 60;
                
                console.log('Real pool time check:', {
                    available_pool_time: availablePoolTime,
                    qup_cost_per_move: qupCostPerMove
                });

                // Calculate how many positions can actually be afforded
                const maxAffordablePositions = Math.floor(availablePoolTime / qupCostPerMove);
                
                const currentQueueLength = queue.length;
                const normalPosition = currentQueueLength; // Where you'd normally be placed (0-based)
                
                // Limit preview position to what's actually affordable
                const maxReachablePosition = Math.max(0, normalPosition - maxAffordablePositions);
                
                if (previewQupPosition < maxReachablePosition) {
                    console.log('Position not affordable, adjusting:', {
                        requested: previewQupPosition + 1,
                        max_reachable: maxReachablePosition + 1,
                        reason: 'insufficient_pool_time'
                    });
                    
                    // Adjust to max reachable position
                    previewQupPosition = maxReachablePosition;
                    showAlert('Position adjusted to maximum affordable with current pool time', 'warning');
                }

                const targetPosition = previewQupPosition; // Where you want to be (0-based)

                // Calculate wait time at preview position
                let waitTimeAtPosition = 0;
                const baseTimePerItem = timeStats.current_base_time_per_item ||
                                       timeStats.current_qup_cost ||
                                       60; // fallback seconds

                if (targetPosition < queue.length) {
                    // Sum up remaining times for orders ahead of preview position
                    for (let i = 0; i < targetPosition; i++) {
                        if (queue[i]) {
                            waitTimeAtPosition += queue[i].remaining_seconds ||
                                                 queue[i].assigned_time ||
                                                 baseTimePerItem;
                        }
                    }
                } else {
                    // Preview position is beyond current queue
                    waitTimeAtPosition = targetPosition * baseTimePerItem;
                }

                // Add your order's processing time
                const yourOrderProcessingTime = baseTimePerItem;
                const totalWaitTime = waitTimeAtPosition + yourOrderProcessingTime;

                // Calculate cost to reach this position
                const positionsToSkip = Math.max(0, normalPosition - targetPosition);
                const totalQupCost = positionsToSkip * qupCostPerMove;
                
                // Check if this position is actually reachable
                const isReachable = totalQupCost <= availablePoolTime;

                // Calculate time savings vs normal position
                const normalWaitTime = (normalPosition + 1) * baseTimePerItem;
                const timeSaved = normalWaitTime - totalWaitTime;

                updatePreviewDisplay(totalWaitTime, baseTimePerItem, timeSaved, normalPosition + 1, {
                    positions_to_skip: positionsToSkip,
                    total_qup_cost: totalQupCost,
                    available_pool_time: availablePoolTime,
                    is_reachable: isReachable,
                    max_affordable_positions: maxAffordablePositions
                });

            } catch (error) {
                console.error('Error calculating preview wait time from queue data:', error);
                calculatePreviewWaitTimeFromEstimate();
            }
        }

        // Last resort: Use reasonable estimates
        function calculatePreviewWaitTimeFromEstimate() {
            const estimatedTimePerOrder = 45; // 45 seconds default
            const cumulativeWaitTime = previewQupPosition * estimatedTimePerOrder;
            updatePreviewDisplay(cumulativeWaitTime, estimatedTimePerOrder);
        }

        // Enhanced updatePreviewDisplay with feasibility validation
        function updatePreviewDisplay(waitTimeSeconds, avgTimePerOrder, timeSaved, normalPosition, feasibilityData) {
            // Format and display the wait time
            const waitMinutes = Math.floor(waitTimeSeconds / 60);
            const waitSecondsRemainder = Math.floor(waitTimeSeconds % 60);
            const waitDisplay = waitMinutes > 0 ? waitMinutes + 'm ' + waitSecondsRemainder + 's' : waitSecondsRemainder + 's';

            document.getElementById('previewWaitTime').textContent = waitDisplay;

            // Update time savings display with feasibility check
            let timeSavingsText;
            
            if (feasibilityData && !feasibilityData.is_reachable) {
                // Position not reachable due to insufficient pool time
                const costDisplay = Math.floor(feasibilityData.total_qup_cost);
                const availableDisplay = Math.floor(feasibilityData.available_pool_time);
                
                timeSavingsText = 'Position not reachable - Need ' + costDisplay + 's pool time, have ' + availableDisplay + 's';
                
                // Disable the up button if current position is not reachable
                const upBtn = document.getElementById('previewQupUpBtn');
                if (upBtn) {
                    upBtn.disabled = true;
                    upBtn.title = 'Insufficient pool time for this position';
                }
                
            } else if (timeSaved > 0) {
                const savedMinutes = Math.floor(timeSaved / 60);
                const savedSeconds = Math.floor(timeSaved % 60);
                timeSavingsText = 'Time saved: ' + savedMinutes + 'm ' + savedSeconds + 's vs normal position #' + normalPosition;
                
                if (feasibilityData) {
                    const costDisplay = Math.floor(feasibilityData.total_qup_cost);
                    timeSavingsText += ' (Cost: ' + costDisplay + 's pool time)';
                }
                
            } else if (timeSaved < 0) {
                const extraMinutes = Math.floor(Math.abs(timeSaved) / 60);
                const extraSeconds = Math.floor(Math.abs(timeSaved) % 60);
                timeSavingsText = 'Extra wait time: ' + extraMinutes + 'm ' + extraSeconds + 's vs normal position #' + normalPosition;
                
            } else {
                timeSavingsText = 'At normal position #' + normalPosition + ' - no time change';
            }

            document.getElementById('previewTimeSavings').textContent = timeSavingsText;

            console.log('Live preview update: Position ' + (previewQupPosition + 1) + ', Wait: ' + waitDisplay + ', Time saved: ' + Math.floor(timeSaved || 0) + 's', feasibilityData || '');
        }

        // Enhanced previewQupUp function with real feasibility checking
        function previewQupUp() {
            if (previewQupPosition > 0) {
                const previousPosition = previewQupPosition;
                previewQupPosition--;
                
                // Update display first
                updateQupPreview();
                
                // Check if this new position is actually reachable
                updatePreviewWaitTime().then(() => {
                    // The updatePreviewWaitTime function will adjust position if not reachable
                    if (previewQupPosition !== previousPosition - 1) {
                        // Position was adjusted due to feasibility
                        updateQupPreview(); // Update display again
                        showAlert('Reached maximum affordable position with current pool time', 'warning');
                    } else {
                        showAlert('Preview: Moving to position ' + (previewQupPosition + 1) + ' - Check time savings!', 'success');
                    }
                }).catch(error => {
                    console.error('Failed to validate preview position:', error);
                    showAlert('Preview: Moving to position ' + (previewQupPosition + 1), 'info');
                });
            } else {
                showAlert('Cannot move up further - already at front!', 'error');
            }
        }

        // Enhanced previewQupDown function
        function previewQupDown() {
            // Get current queue length for reasonable limit
            const maxPosition = Math.max(10, parseInt(document.getElementById('previewPosition').textContent.match(/\d+/)[0]));

            if (previewQupPosition < maxPosition) {
                previewQupPosition++;
                updateQupPreview();
                updatePreviewWaitTime(); // Update wait time display with real data
                showAlert('Preview: Moving to position ' + (previewQupPosition + 1), 'info');
            } else {
                showAlert('Cannot move down further', 'error');
            }
        }

        // Get client configuration from server
        async function getClientConfig() {
            try {
                console.log('Getting client configuration from server...');

                const response = await fetch(API_BASE + '/api/client/config');
                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }

                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    throw new Error('Invalid response format: Expected JSON');
                }

                const data = await response.json();

                if (response.ok && data.config) {
                    SUPABASE_URL = data.config.supabase_url;
                    SUPABASE_ANON_KEY = data.config.supabase_anon_key;

                    console.log('Client configuration loaded from server');
                    return true;
                } else {
                    throw new Error('Failed to get client configuration');
                }
            } catch (error) {
                console.error('Failed to get client config:', error);
                showAlert('Failed to load configuration from server', 'error');
                return false;
            }
        }

        function initializeSupabase() {
            try {
                if (!SUPABASE_URL || SUPABASE_URL === 'YOUR_SUPABASE_URL' ||
                    !SUPABASE_ANON_KEY || SUPABASE_ANON_KEY === 'YOUR_SUPABASE_ANON_KEY') {
                    console.error('Supabase configuration missing from server');
                    showAlert('Supabase configuration missing. Please contact administrator.', 'error');
                    return false;
                }

                supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);
                console.log('Supabase client initialized with server config');
                return true;
            } catch (error) {
                console.error('Supabase initialization failed:', error);
                showAlert('Failed to initialize authentication system.', 'error');
                return false;
            }
        }

        // Initialize app
        async function init() {
            console.log('QUP Client initializing...');

            // Get configuration from server first
            const configLoaded = await getClientConfig();
            if (!configLoaded) {
                showLogin();
                return;
            }

            // Initialize Supabase with server config
            if (!initializeSupabase()) {
                showLogin();
                return;
            }

            // Load logo and settings
            await loadCompanyAssets();

            // Check if user is already logged in
            try {
                const { data: { user } } = await supabase.auth.getUser();
                if (user) {
                    showApp(user);
                } else {
                    showLogin();
                }
            } catch (error) {
                console.error('Failed to check user session:', error);
                showLogin();
            }
        }

        // Load company logo and settings
        async function loadCompanyAssets() {
            try {
                // Load current logo
                const { data: logoData, error: logoError } = await supabase
                    .from('company_logos')
                    .select('*')
                    .eq('is_active', true)
                    .order('uploaded_at', { ascending: false })
                    .limit(1);

                if (!logoError && logoData && logoData.length > 0) {
                    currentLogo = logoData[0];
                } else {
                    currentLogo = { logo_url: DEFAULT_LOGO_URL };
                }

                // Load logo settings
                const { data: settingsData, error: settingsError } = await supabase
                    .from('logo_settings')
                    .select('*')
                    .limit(1);

                if (!settingsError && settingsData && settingsData.length > 0) {
                    logoSettings = settingsData[0];
                }

                // Ensure default logo settings with null coalescing
                logoSettings = {
                    show_client: logoSettings && logoSettings.show_client !== undefined ? logoSettings.show_client : true,
                    client_size: logoSettings && logoSettings.client_size !== undefined ? logoSettings.client_size : 50,
                    enable_rain: logoSettings && logoSettings.enable_rain !== undefined ? logoSettings.enable_rain : true,
                    rain_intensity: logoSettings && logoSettings.rain_intensity !== undefined ? logoSettings.rain_intensity : 3,
                    rain_opacity: logoSettings && logoSettings.rain_opacity !== undefined ? logoSettings.rain_opacity : 30
                };

                updateLogoDisplays();
                console.log('Company assets loaded:', { currentLogo: !!currentLogo, logoSettings: logoSettings });

            } catch (error) {
                console.error('Failed to load company assets:', error);
                // Use defaults on error
                currentLogo = { logo_url: DEFAULT_LOGO_URL };
                logoSettings = {
                    show_client: true,
                    client_size: 50,
                    enable_rain: true,
                    rain_intensity: 3,
                    rain_opacity: 30
                };
            }
        }

        function updateLogoDisplays() {
            console.log('Updating client logo displays...', { currentLogo: currentLogo, logoSettings: logoSettings });
            if (!currentLogo) {
                currentLogo = { logo_url: DEFAULT_LOGO_URL };
            }

            const loginLogo = document.getElementById('loginLogo');
            const appLogo = document.getElementById('appLogo');

            if (loginLogo && appLogo) {
                const logoUrl = currentLogo.logo_url;
                const logoSize = logoSettings && logoSettings.client_size ? logoSettings.client_size : 50;
                const showClient = logoSettings && logoSettings.show_client !== undefined ? logoSettings.show_client : true;

                console.log('Setting client logos:', logoUrl);

                // Update login logo
                loginLogo.src = logoUrl;
                loginLogo.alt = 'QUP Company Logo';
                loginLogo.style.height = logoSize + 'px';
                loginLogo.style.display = showClient ? 'block' : 'none';

                // Update app logo
                appLogo.src = logoUrl;
                appLogo.alt = 'QUP Company Logo';
                appLogo.style.height = logoSize + 'px';
                appLogo.style.display = showClient ? 'block' : 'none';

                console.log('Logo displays updated for client');
            } else {
                console.error('Logo elements not found');
            }
        }

        // Logo Rain System
        function startLogoRain() {
            console.log('Starting logo rain...', { currentLogo: currentLogo, logoSettings: logoSettings });
            if (!currentLogo) {
                console.log('No current logo - using default URL for rain');
                currentLogo = {
                    logo_url: DEFAULT_LOGO_URL
                };
            }
            if (!logoSettings) {
                logoSettings = { enable_rain: true, rain_intensity: 3, rain_opacity: 30 };
            }
            if (!logoSettings.enable_rain) {
                console.log('Logo rain disabled');
                return;
            }

            const rainContainer = document.getElementById('logoRain');
            if (!rainContainer) {
                console.error('Rain container not found');
                return;
            }

            const rainIntensity = logoSettings.rain_intensity || 3;
            const rainOpacity = (logoSettings.rain_opacity || 30) / 100;

            console.log('Rain settings:', { rainIntensity: rainIntensity, rainOpacity: rainOpacity });

            logoRainInterval = setInterval(function() {
                createRainLogo(rainContainer, rainOpacity);
            }, 1000 / rainIntensity);

            console.log('Logo rain started');
        }

        function createRainLogo(container, opacity) {
            if (!currentLogo) return;

            const logoElement = document.createElement('img');
            logoElement.src = currentLogo.logo_url;
            logoElement.className = 'rain-logo';
            logoElement.style.left = Math.random() * window.innerWidth + 'px';
            logoElement.style.opacity = opacity;
            logoElement.style.animationDuration = (Math.random() * 3 + 3) + 's';
            logoElement.style.animationDelay = Math.random() * 2 + 's';

            // Prevent drag and context menu
            logoElement.draggable = false;
            logoElement.oncontextmenu = function() { return false; };
            logoElement.onselectstart = function() { return false; };
            logoElement.ondragstart = function() { return false; };

            container.appendChild(logoElement);

            // Remove after animation
            setTimeout(function() {
                if (logoElement.parentNode) {
                    logoElement.remove();
                }
            }, 8000);
        }

        function stopLogoRain() {
            if (logoRainInterval) {
                clearInterval(logoRainInterval);
                logoRainInterval = null;

                // Clear existing rain logos
                const rainContainer = document.getElementById('logoRain');
                rainContainer.innerHTML = '';

                console.log('Logo rain stopped');
            }
        }

        // Logo Overlay Protection System
        function startLogoOverlay() {
            console.log('Starting logo overlay protection...');
            if (!currentLogo) {
                console.log('No current logo - using default URL for overlay');
                currentLogo = {
                    logo_url: DEFAULT_LOGO_URL
                };
            }

            const overlayContainer = document.getElementById('logoOverlay');
            if (!overlayContainer) {
                console.error('Overlay container not found');
                return;
            }

            // Create multiple floating logos over the pickup code
            for (let i = 0; i < 8; i++) {
                createOverlayLogo(overlayContainer, i);
            }

            // Continuously add new logos to maintain coverage
            logoOverlayInterval = setInterval(function() {
                if (overlayContainer.children.length < 12) {
                    createOverlayLogo(overlayContainer, Math.floor(Math.random() * 100));
                }
            }, 2000);

            console.log('Logo overlay protection started');
        }

        function createOverlayLogo(container, index) {
            if (!currentLogo) return;

            const logo = document.createElement('img');
            logo.src = currentLogo.logo_url;
            logo.className = 'overlay-logo';

            // Random positioning within the overlay area
            logo.style.left = Math.random() * 90 + 5 + '%';
            logo.style.top = Math.random() * 90 + 5 + '%';

            // Vary animation duration and delay for more randomness
            logo.style.animationDuration = (2 + Math.random() * 3) + 's';
            logo.style.animationDelay = (Math.random() * 2) + 's';

            // Prevent drag and context menu
            logo.draggable = false;
            logo.oncontextmenu = function() { return false; };
            logo.onselectstart = function() { return false; };
            logo.ondragstart = function() { return false; };

            container.appendChild(logo);

            // Remove after some time and replace
            setTimeout(function() {
                if (logo.parentNode) {
                    logo.remove();
                }
            }, 8000 + Math.random() * 4000);
        }

        function stopLogoOverlay() {
            if (logoOverlayInterval) {
                clearInterval(logoOverlayInterval);
                logoOverlayInterval = null;

                // Clear existing overlay logos
                const overlayContainer = document.getElementById('logoOverlay');
                if (overlayContainer) {
                    overlayContainer.innerHTML = '';
                }

                console.log('Logo overlay protection stopped');
            }
        }

        // Load queue preview with current user context
        async function loadQueuePreview() {
            try {
                console.log('Loading queue preview...');

                // Use current user email if available
                let previewEmail = currentUser && currentUser.email ? currentUser.email : 'chris@qupcorp.com';

                const keyResponse = await fetch(API_BASE + '/api/client/api-key', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ user_email: previewEmail })
                });

                if (keyResponse.ok) {
                    const keyData = await keyResponse.json();
                    const previewKey = keyData.api_key;

                    console.log('Got preview API key, fetching queue preview...');

                    // Get queue preview
                    const response = await fetch(API_BASE + '/api/v1/queue/preview-join', {
                        headers: { 'X-API-Key': previewKey }
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log('Queue preview data:', data);
                        updateQueuePreview(data);
                    } else {
                        console.error('Failed to get queue preview:', response.status);
                        setDefaultPreview();
                    }
                } else {
                    console.error('Failed to get preview API key');
                    setDefaultPreview();
                }
            } catch (error) {
                console.error('Failed to load queue preview:', error);
                setDefaultPreview();
            }
        }

        function setDefaultPreview() {
            updateQueuePreview({
                preview_data: {
                    estimated_wait_time: 60,
                    estimated_position: 1
                }
            });
        }

        // Update queue preview display
        function updateQueuePreview(data) {
            if (data.preview_data) {
                const waitMinutes = Math.floor(data.preview_data.estimated_wait_time / 60);
                const waitSeconds = data.preview_data.estimated_wait_time % 60;
                const waitDisplay = waitMinutes > 0 ? waitMinutes + 'm ' + waitSeconds + 's' : waitSeconds + 's';

                document.getElementById('previewWaitTime').textContent = waitDisplay;
                document.getElementById('previewPosition').textContent = '#' + data.preview_data.estimated_position;
            }
        }

        // Authentication functions - REQUIRED Supabase login
        async function handleLogin() {
            if (!supabase) {
                showAlert('Authentication system not ready. Please refresh the page.', 'error');
                return;
            }

            const email = document.getElementById('email').value.trim();
            const password = document.getElementById('password').value.trim();

            if (!email || !password) {
                showAlert('Please enter both email and password', 'error');
                return;
            }

            setLoading('login', true);
            hideElement('loginError');

            try {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: email,
                    password: password
                });

                if (error) {
                    throw error;
                }

                console.log('Supabase login successful');
                showApp(data.user);

            } catch (error) {
                console.error('Login failed:', error);
                showElement('loginError');
                showAlert('Login failed: ' + error.message, 'error');
            } finally {
                setLoading('login', false);
            }
        }

        async function logout() {
            if (!supabase) return;

            try {
                await supabase.auth.signOut();
                console.log('Logged out');

                // Cleanup ALL intervals to prevent memory leaks
                stopLogoRain();
                stopLogoOverlay();

                if (socket) {
                    socket.disconnect();
                    socket = null;
                }

                if (waitTimeInterval) {
                    clearInterval(waitTimeInterval);
                    waitTimeInterval = null;
                }

                if (orderStatusInterval) {
                    clearInterval(orderStatusInterval);
                    orderStatusInterval = null;
                }

                currentUser = null;
                currentOrder = null;
                currentOrderData = null;
                developerKey = null;
                qupEnabled = false;
                currentPosition = 1;

                showLogin();

            } catch (error) {
                console.error('Logout failed:', error);
            }
        }

        // App initialization
        async function showApp(user) {
            currentUser = user;

            hideElement('loginScreen');
            showElement('appScreen');
            document.getElementById('userEmail').textContent = user.email;

            // Pre-fill customer name from email
            const customerNameField = document.getElementById('customerName');
            if (customerNameField && user.email) {
                // Extract name from email (before @)
                const emailUsername = user.email.split('@')[0];
                // Convert underscores/dots to spaces and capitalize
                const suggestedName = emailUsername.replace(/[._]/g, ' ').replace(/\b\w/g, function(l) { return l.toUpperCase(); });
                customerNameField.value = suggestedName;
            }

            // Load queue preview with user context
            await loadQueuePreview();

            // Get developer key for API access
            await getDeveloperKey();

            // Connect WebSocket
            connectWebSocket();

            console.log('App initialized for:', user.email);
        }

        function showLogin() {
            hideElement('appScreen');
            showElement('loginScreen');
            stopLogoRain();
            stopLogoOverlay();

            // Clear form
            document.getElementById('email').value = '';
            document.getElementById('password').value = '';
        }

        // Get developer key for API access from server environment
        async function getDeveloperKey() {
            try {
                console.log('Getting API key from server...');

                const response = await fetch(API_BASE + '/api/client/api-key', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        user_email: currentUser.email
                    })
                });

                if (!response.ok) {
                    throw new Error('HTTP ' + response.status + ': ' + response.statusText);
                }

                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    throw new Error('Invalid response format: Expected JSON');
                }

                const data = await response.json();

                if (data.api_key) {
                    developerKey = data.api_key;
                    console.log('API key obtained from server environment');
                } else {
                    throw new Error(data.error || 'No API key in response');
                }
            } catch (error) {
                console.error('API key error:', error);
                showAlert('Failed to get API access. Please contact administrator.', 'error');
            }
        }

        // WebSocket connection
        function connectWebSocket() {
            try {
                console.log('Connecting to WebSocket...');

                socket = window.io(API_BASE, {
                    transports: ['websocket', 'polling'],
                    timeout: 20000,
                    reconnection: true,
                    reconnectionDelay: 2000,
                    reconnectionAttempts: 5,
                    forceNew: true
                });

                socket.on('connect', function() {
                    updateConnectionStatus(true);
                    console.log('WebSocket connected');

                    // Subscribe to order updates for this user
                    if (currentOrder) {
                        socket.emit('subscribe', { orderId: currentOrder });
                        console.log('Subscribed to order updates for:', currentOrder);
                    }
                });

                socket.on('disconnect', function() {
                    updateConnectionStatus(false);
                    console.log('WebSocket disconnected');
                });

                socket.on('connect_error', function(error) {
                    console.error('WebSocket connection error:', error);
                    updateConnectionStatus(false);
                });

                socket.on('order_update', function(data) {
                    console.log('Order update received:', data);
                    handleOrderUpdate(data);
                });

                socket.on('subscribed_order_update', function(data) {
                    console.log('Subscribed order update:', data);
                    handleOrderUpdate(data);
                });

                socket.on('order_finalized', function(data) {
                    console.log('Order finalized event:', data);
                    if (currentOrder && (data.orderId === currentOrder || data.id === currentOrder || data.order_id === currentOrder) && data.pickupCode) {
                        showPickupCode(data.pickupCode);
                    }
                });

                socket.on('order_completed', function(data) {
                    console.log('Order completed event:', data);
                    if (currentOrder && (data.orderId === currentOrder || data.id === currentOrder || data.order_id === currentOrder)) {
                        console.log('My order completed via order_completed event');
                        showOrderComplete();
                    }
                });

                socket.on('order_complete', function(data) {
                    console.log('Order complete event:', data);
                    if (currentOrder && (data.orderId === currentOrder || data.id === currentOrder || data.order_id === currentOrder)) {
                        console.log('My order completed via order_complete event');
                        showOrderComplete();
                    }
                });

                // KEY FIX: Listen for queue updates and detect order removal
                socket.on('queue_update', function(data) {
                    console.log('Queue update received:', data);

                    // Check if our order is no longer in the queue (indicating completion)
                    if (currentOrder && data.queue) {
                        const myOrder = data.queue.find(function(order) {
                            return order.id === currentOrder || order.order_id === currentOrder;
                        });

                        if (myOrder) {
                            // Order still in queue, update its status AND wait time
                            handleMyOrderUpdate(myOrder);
                        } else {
                            // Order not in queue anymore - it was completed!
                            console.log('My order no longer in queue - completed!');
                            // Don't trigger if already showing complete section
                            if (document.getElementById('completeSection').classList.contains('hidden')) {
                                showOrderComplete();
                            }
                        }
                    }

                    // Update preview if user is currently previewing
                    if (document.getElementById('qupPreviewControls').classList.contains('hidden') === false) {
                        updatePreviewWaitTime();
                    }

                    // CRITICAL FIX: Update wait time for queue changes even without order data
                    if (currentOrder && !data.queue) {
                        // Force refresh order data when queue changes but no order data provided
                        updateOrderDisplay();
                    }
                });

                socket.on('order_status_change', function(data) {
                    console.log('Order status change event:', data);
                    if (currentOrder && (data.orderId === currentOrder || data.id === currentOrder || data.order_id === currentOrder)) {
                        if (data.status === 'completed' || data.action === 'completed' || data.status === 'complete') {
                            console.log('My order completed via status change event');
                            showOrderComplete();
                        }
                    }
                });

                socket.on('qup_performed', function(data) {
                    console.log('QUP performed:', data);
                    if (currentOrder && (data.element_id === currentOrder || data.user_id === currentUser.email)) {
                        showAlert('QUP successful! Moved to position ' + (data.to_position + 1), 'success');
                        updateOrderDisplay();
                    }

                    // Update preview if user is currently previewing
                    if (document.getElementById('qupPreviewControls').classList.contains('hidden') === false) {
                        updatePreviewWaitTime();
                    }
                });

                socket.on('downward_movement', function(data) {
                    console.log('Downward movement:', data);
                    if (currentOrder && (data.element_id === currentOrder || data.user_id === currentUser.email)) {
                        showAlert('Moved down to position ' + (data.to_position + 1), 'info');
                        updateOrderDisplay();
                    }
                });

                socket.on('error', function(error) {
                    console.error('WebSocket error:', error);
                });

            } catch (error) {
                console.error('WebSocket connection failed:', error);
                updateConnectionStatus(false);
            }
        }

        function updateConnectionStatus(connected) {
            const status = document.getElementById('connectionStatus');
            if (!status) return;

            if (connected) {
                status.className = 'connection-status connected';
                status.innerHTML = '<div class="connection-dot"></div><span>Connected</span>';
            } else {
                status.className = 'connection-status disconnected';
                status.innerHTML = '<div class="connection-dot"></div><span>Disconnected</span>';
            }
        }

        // Enhanced placeOrder function with adaptive direct placement
        async function placeOrder() {
            // Prevent multiple submissions
            if (orderSubmitting) {
                console.log('Order already being submitted...');
                return;
            }

            const customerName = document.getElementById('customerName').value.trim();
            const description = document.getElementById('orderDescription').value.trim();
            qupEnabled = document.getElementById('enableQup').checked;

            if (!customerName) {
                showAlert('Please enter your name', 'error');
                return;
            }

            if (!description) {
                showAlert('Please enter your order description', 'error');
                return;
            }

            if (!developerKey) {
                showAlert('API not ready. Please try again.', 'error');
                return;
            }

            orderSubmitting = true;
            setLoading('order', true);

            try {
                const orderId = currentUser.email.replace('@', '_').replace('.', '_') + '_' + Date.now();

                // Prepare order data with preview position if QUP enabled
                const orderPayload = {
                    id: orderId,
                    payload: {
                        order: description,
                        customer_email: currentUser.email,
                        customer_name: customerName,
                        items: [{ name: description, quantity: 1 }],
                        qup_enabled: qupEnabled
                    },
                    user_id: currentUser.email,
                    priority: 500
                };

                // Add target position for direct placement (works with regular QUP OR Force QUP)
                if (qupEnabled && previewQupPosition !== null) {
                    orderPayload.target_position = previewQupPosition + 1; // Convert to 1-based
                    console.log('DIRECT PLACEMENT: Requesting position ' + (previewQupPosition + 1) + ' (backend will decide QUP method)');
                }

                console.log('Placing order:', orderPayload);

                const response = await fetch(API_BASE + '/api/v1/queue/add', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': developerKey
                    },
                    body: JSON.stringify(orderPayload)
                });

                const data = await response.json();

                if (response.ok) {
                    // CRITICAL FIX: Use backend's order ID, not client's
                    currentOrder = data.id || data.order_id || orderId;
                    currentPosition = data.position || 0;

                    console.log('Order result:', {
                        client_id: orderId,
                        backend_id: currentOrder,
                        requested: orderPayload.target_position,
                        actual: data.position + 1,
                        type: data.placement_type,
                        force_qup_used: data.enhanced_features && data.enhanced_features.force_qup_available ? data.enhanced_features.force_qup_available : false
                    });

                    // Adaptive success message based on what backend actually did
                    const placementMessage = getPlacementMessage(data, orderPayload.target_position);
                    showAlert(placementMessage.text, placementMessage.type);

                    // Subscribe to order updates using BACKEND'S order ID
                    if (socket && socket.connected) {
                        socket.emit('subscribe', { orderId: currentOrder });
                        console.log('Subscribed to order updates for:', currentOrder);
                    }

                    // Show order status
                    showOrderStatus(customerName, description, data);
                    hideElement('orderForm');
                    hideElement('queuePreview');

                    // Show QUP controls if enabled
                    if (qupEnabled) {
                        showQupControls(data.position || 0);
                    }

                    // Start polling for updates
                    startOrderPolling();

                } else {
                    throw new Error(data.error || 'Failed to place order');
                }

            } catch (error) {
                console.error('Order failed:', error);
                showAlert('Order failed: ' + error.message, 'error');
            } finally {
                setLoading('order', false);
                orderSubmitting = false;
            }
        }

        // Adaptive placement message based on backend behavior
        function getPlacementMessage(data, requestedPosition) {
            const actualPosition = data.position + 1;
            const placementType = data.placement_type;
            const forceQupAvailable = data.enhanced_features && data.enhanced_features.force_qup_available ? data.enhanced_features.force_qup_available : false;

            // Direct placement succeeded
            if (placementType === 'direct_position' && requestedPosition && actualPosition === requestedPosition) {
                if (forceQupAvailable) {
                    return { text: 'Force QUP Success! Placed directly at position #' + actualPosition + '!', type: 'success' };
                } else {
                    return { text: 'Regular QUP Success! Placed directly at position #' + actualPosition + '!', type: 'success' };
                }
            }

            // Direct placement attempted fell back
            if (requestedPosition && actualPosition !== requestedPosition) {
                if (forceQupAvailable) {
                    return { text: 'Placed at #' + actualPosition + '. Target #' + requestedPosition + ' required more resources even with Force QUP.', type: 'info' };
                } else {
                    return { text: 'Placed at #' + actualPosition + '. Target #' + requestedPosition + ' required more pool time (Ask admin for Force QUP).', type: 'info' };
                }
            }

            // Normal placement (no preview used)
            if (forceQupAvailable) {
                return { text: 'Order placed at position #' + actualPosition + ' (Force QUP available for moves)', type: 'success' };
            } else {
                return { text: 'Order placed at position #' + actualPosition, type: 'success' };
            }
        }

        // Show QUP controls
        function showQupControls(position) {
            currentPosition = position;
            document.getElementById('currentQupPosition').textContent = '#' + (position + 1);
            updateQupButtons();
            showElement('qupControls');
            updateTimeSavings();
        }

        // Update QUP button states
        function updateQupButtons() {
            const upBtn = document.getElementById('qupUpBtn');
            const downBtn = document.getElementById('qupDownBtn');

            // Can move up if not at position 0 and have pool time
            upBtn.disabled = currentPosition <= 0;

            // Can move down if not at the back and have downward moves available
            downBtn.disabled = currentPosition >= 10; // Reasonable limit

            // Update pool time display
            document.getElementById('poolTimeDisplay').textContent = '120s'; // Default for demo
        }

        // Update time savings display
        function updateTimeSavings() {
            const baseTimePerPosition = 60; // 1 minute per position
            const timeSaved = (currentPosition) * baseTimePerPosition;
            const minutes = Math.floor(timeSaved / 60);
            document.getElementById('timeSavings').textContent =
                'Time saved by moving up: ' + minutes + ' minute' + (minutes !== 1 ? 's' : '');
        }

        // Enhanced performQupUp with adaptive backend response handling
        async function performQupUp() {
            if (!currentOrder || !developerKey || currentPosition <= 0) {
                showAlert('Cannot move up further', 'error');
                return;
            }

            try {
                showAlert('Moving up...', 'info');

                const response = await fetch(API_BASE + '/api/v1/queue/qup', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': developerKey
                    },
                    body: JSON.stringify({
                        element_id: currentOrder,
                        user_id: currentUser.email
                    })
                });

                const data = await response.json();

                if (response.ok && data.status === 'success') {
                    // Update position from backend response
                    if (data.queue_info && data.queue_info.queue) {
                        const myOrder = data.queue_info.queue.find(function(order) {
                            return order.id === currentOrder;
                        });
                        if (myOrder) {
                            currentPosition = myOrder.position;
                        }
                    } else {
                        currentPosition = Math.max(0, currentPosition - 1);
                    }

                    document.getElementById('currentQupPosition').textContent = '#' + (currentPosition + 1);
                    updateQupButtons();
                    updateTimeSavings();

                    // Adaptive success message based on backend method used
                    const qupMessage = getQupSuccessMessage(data);
                    showAlert(qupMessage, 'success');
                    updateOrderDisplay();
                } else {
                    const errorMsg = data.message || data.error || 'QUP failed';
                    // Show helpful error message based on backend response
                    const helpfulError = getHelpfulQupError(data, errorMsg);
                    showAlert(helpfulError, 'error');
                    console.log('QUP failed response:', data);
                }

            } catch (error) {
                console.error('QUP error:', error);
                showAlert('QUP error: ' + error.message, 'error');
            }
        }

        // Enhanced performQupDown with adaptive backend response handling
        async function performQupDown() {
            if (!currentOrder || !developerKey) {
                showAlert('Cannot move down', 'error');
                return;
            }

            try {
                showAlert('Moving down...', 'info');

                const response = await fetch(API_BASE + '/api/v1/queue/move-down', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-API-Key': developerKey
                    },
                    body: JSON.stringify({
                        element_id: currentOrder,
                        user_id: currentUser.email
                    })
                });

                const data = await response.json();

                if (response.ok && data.status === 'success') {
                    // Update position from backend response
                    if (data.queue_info && data.queue_info.queue) {
                        const myOrder = data.queue_info.queue.find(function(order) {
                            return order.id === currentOrder;
                        });
                        if (myOrder) {
                            currentPosition = myOrder.position;
                        }
                    } else {
                        currentPosition = currentPosition + 1;
                    }

                    document.getElementById('currentQupPosition').textContent = '#' + (currentPosition + 1);
                    updateQupButtons();
                    updateTimeSavings();
                    showAlert('Moved down to position #' + (currentPosition + 1), 'success');
                    updateOrderDisplay();
                } else {
                    const errorMsg = data.message || data.error || 'Move down failed';
                    showAlert('Move down failed: ' + errorMsg, 'error');
                }

            } catch (error) {
                console.error('Move down error:', error);
                showAlert('Move down error: ' + error.message, 'error');
            }
        }

        // Get success message based on backend QUP method used
        function getQupSuccessMessage(data) {
            const forceQupUsed = (data.revolutionary_features && data.revolutionary_features.robin_hood_of_time) ||
                                data.force_qup_enabled ||
                                (data.message && data.message.includes('Force QUP')) ||
                                (data.message && data.message.includes('force'));

            if (forceQupUsed) {
                return 'Force QUP Success! Now at position #' + (currentPosition + 1) + ' (affected users compensated)';
            } else {
                return 'Regular QUP Success! Now at position #' + (currentPosition + 1);
            }
        }

        // Get helpful error message based on backend response
        function getHelpfulQupError(data, originalError) {
            const error = originalError.toLowerCase();

            // Check for common error patterns and provide helpful suggestions
            if (error.includes('insufficient time') || error.includes('pool time')) {
                if (data.force_qup_enabled === false) {
                    return originalError + ' (Ask admin to enable Force QUP for unlimited moves)';
                } else {
                    return originalError;
                }
            }

            if (error.includes('bypass') || error.includes('already bypassed')) {
                return 'Cannot bypass same user twice (fairness rule)';
            }

            if (error.includes('position')) {
                return originalError;
            }

            // Default with suggestion
            if (data.force_qup_enabled === false) {
                return originalError + ' (Force QUP disabled - contact admin if needed)';
            }

            return originalError;
        }

        // Enhanced updateQupButtonsFromBackend to work with any backend state
        function updateQupButtonsFromBackend(orderData) {
            const upBtn = document.getElementById('qupUpBtn');
            const downBtn = document.getElementById('qupDownBtn');

            // Use backend flags for accurate button states (works with regular QUP or Force QUP)
            upBtn.disabled = !orderData.can_qup || currentPosition <= 0;
            downBtn.disabled = !orderData.can_move_down;

            // Update pool time display from backend
            if (orderData.qup_time_available !== undefined) {
                document.getElementById('poolTimeDisplay').textContent = Math.round(orderData.qup_time_available) + 's';
            }

            // Adaptive status messages based on backend capabilities
            const timeSavingsElement = document.getElementById('timeSavings');
            // Show status based on what backend tells us
            if (!orderData.can_qup) {
                if (orderData.qup_time_available < 60) {
                    const shortfall = 60 - Math.round(orderData.qup_time_available);
                    timeSavingsElement.textContent = 'Need ' + shortfall + 's more pool time for regular QUP';
                } else if (orderData.consecutive_up_moves > 0) {
                    timeSavingsElement.textContent = 'QUP limit reached (' + orderData.consecutive_up_moves + ' moves used)';
                } else {
                    timeSavingsElement.textContent = 'QUP not available';
                }

                // Add Force QUP hint if available
                if (orderData.force_qup_available === false) {
                    timeSavingsElement.textContent += ' (Ask admin for Force QUP)';
                }
            } else if (!orderData.can_move_down) {
                timeSavingsElement.textContent = 'Move down not available';
            } else {
                // Both QUP and move down available - show normal time savings
                updateTimeSavings();

                // Add backend method indicator
                if (orderData.force_qup_available) {
                    timeSavingsElement.textContent += ' (Force QUP enabled)';
                } else {
                    timeSavingsElement.textContent += ' (Regular QUP)';
                }
            }
        }

        // Add this new function to show backend status in real-time
        function updateBackendStatus(orderData) {
            // Update pool time display with backend method indication
            const poolDisplay = document.getElementById('poolTimeDisplay');
            if (poolDisplay && orderData.qup_time_available !== undefined) {
                const poolTime = Math.round(orderData.qup_time_available);
                const forceQupAvailable = orderData.force_qup_available;

                if (forceQupAvailable) {
                    poolDisplay.textContent = poolTime + 's + Force QUP';
                } else {
                    poolDisplay.textContent = poolTime + 's (regular)';
                }
            }

            // Log backend capabilities for debugging
            console.log('Backend QUP Status:', {
                can_qup: orderData.can_qup,
                can_move_down: orderData.can_move_down,
                pool_time: orderData.qup_time_available,
                force_qup_available: orderData.force_qup_available,
                consecutive_moves: orderData.consecutive_up_moves
            });
        }

        function showOrderStatus(customerName, description, orderData) {
            document.getElementById('orderCustomerName').textContent = customerName;
            document.getElementById('orderDetails').textContent = description;
            document.getElementById('orderCurrentStatus').textContent = 'Waiting in queue';
            document.getElementById('orderPosition').textContent = '#' + ((orderData.position || 0) + 1);

            // Calculate estimated completion time
            if (orderData.estimated_time) {
                estimatedCompletionTime = new Date(Date.now() + (orderData.estimated_time * 1000));
                startWaitTimeCountdown();
            }

            // Show order status
            showElement('orderStatus');
        }

        function startWaitTimeCountdown() {
            if (waitTimeInterval) {
                clearInterval(waitTimeInterval);
            }

            waitTimeInterval = setInterval(function() {
                if (!estimatedCompletionTime) return;

                const now = new Date();
                const timeLeft = estimatedCompletionTime - now;

                if (timeLeft <= 0) {
                    document.getElementById('orderWaitTime').textContent = 'Any moment now...';
                    clearInterval(waitTimeInterval);
                    waitTimeInterval = null;
                } else {
                    const minutes = Math.floor(timeLeft / (1000 * 60));
                    const seconds = Math.floor((timeLeft % (1000 * 60)) / 1000);
                    document.getElementById('orderWaitTime').textContent = minutes + 'm ' + seconds + 's';
                }
            }, 1000);
        }

        // Enhanced updateOrderDisplay with wait time updates
        async function updateOrderDisplay() {
            if (!currentOrder || !developerKey) return;

            try {
                const response = await fetch(API_BASE + '/api/v1/queue/list', {
                    headers: {
                        'X-API-Key': developerKey
                    }
                });

                const data = await response.json();

                if (response.ok && data.queue) {
                    const myOrder = data.queue.find(function(order) {
                        return order.id === currentOrder;
                    });
                    if (myOrder) {
                        handleMyOrderUpdate(myOrder);
                    } else {
                        console.log('Order not found in queue - checking if completed');
                        // Order might be completed, check completion
                        checkOrderCompletion();
                    }
                } else {
                    console.error('Failed to get queue data:', data);
                }
            } catch (error) {
                console.error('Failed to update order display:', error);
            }
        }

        // NEW: Check if order was completed
        async function checkOrderCompletion() {
            try {
                const response = await fetch(API_BASE + '/api/v1/queue/order/' + currentOrder, {
                    headers: {
                        'X-API-Key': developerKey
                    }
                });

                if (response.ok) {
                    const orderData = await response.json();
                    if (orderData.status === 'completed' || orderData.completed) {
                        showOrderComplete();
                    }
                } else if (response.status === 404) {
                    // Order not found, likely completed
                    console.log('Order not found via API - assuming completed');
                    showOrderComplete();
                }
            } catch (error) {
                console.error('Failed to check order completion:', error);
            }
        }

        // Start polling for order updates every 3 seconds
        function startOrderPolling() {
            if (orderStatusInterval) {
                clearInterval(orderStatusInterval);
            }

            orderStatusInterval = setInterval(function() {
                if (currentOrder && !document.getElementById('pickupSection').classList.contains('hidden')) {
                    // Stop polling if pickup code is showing
                    clearInterval(orderStatusInterval);
                    orderStatusInterval = null;
                } else if (currentOrder) {
                    updateOrderDisplay();
                }
            }, 3000);
        }

        function handleOrderUpdate(data) {
            if (!currentOrder || (data.orderId !== currentOrder && data.id !== currentOrder && data.order_id !== currentOrder)) {
                return;
            }

            console.log('Handling order update for my order:', data.action || data.status);

            // Check for completion first
            if (data.action === 'completed' || data.action === 'complete' ||
                data.status === 'completed' || data.status === 'complete' ||
                data.completed === true || data.is_completed === true) {
                console.log('Order completion detected in update');
                showOrderComplete();
                return;
            }

            // Handle other states
            switch (data.action || data.status) {
                case 'finalized':
                case 'pickup_ready':
                    if (data.pickup_code && data.pickup_code !== 'PENDING') {
                        showPickupCode(data.pickup_code);
                    }
                    break;

                case 'cancelled':
                    showAlert('Your order has been cancelled', 'error');
                    startNewOrder();
                    break;
            }
        }

        // Enhanced handleMyOrderUpdate with live wait time calculation
        function handleMyOrderUpdate(orderData) {
            console.log('My order data updated:', orderData);
            currentOrderData = orderData;

            // Check for completion first - if order is no longer in queue, it's completed
            if (!orderData || orderData.status === 'completed' || orderData.completed === true) {
                console.log('Order completed detected in handleMyOrderUpdate');
                showOrderComplete();
                return;
            }

            // Update position display
            const positionElement = document.getElementById('orderPosition');
            if (positionElement) {
                positionElement.textContent = '#' + (orderData.position + 1);

                // Update QUP controls position if enabled
                if (qupEnabled) {
                    currentPosition = orderData.position;
                    document.getElementById('currentQupPosition').textContent = '#' + (currentPosition + 1);
                    updateQupButtonsFromBackend(orderData); // Use backend data for button states
                    updateTimeSavings();
                }
            }

            // CRITICAL FIX: Update wait time in real-time
            updateLiveWaitTime(orderData);

            if (orderData.finalized && orderData.pickup_code && orderData.pickup_code !== 'PENDING') {
                // Only show pickup code if not already showing it
                if (document.getElementById('pickupSection').classList.contains('hidden')) {
                    showPickupCode(orderData.pickup_code);
                }
            } else if (orderData.cancelled) {
                showAlert('Your order has been cancelled', 'error');
                startNewOrder();
            } else {
                updateOrderPosition(orderData);
            }
        }

        // NEW: Update wait time in real-time based on current queue state
        function updateLiveWaitTime(orderData) {
            // Calculate live wait time based on current position and queue state
            if (orderData.remaining_seconds !== undefined) {
                // Use backend's calculated remaining time
                estimatedCompletionTime = new Date(Date.now() + (orderData.remaining_seconds * 1000));
            } else if (orderData.estimated_completion) {
                // Use backend's estimated completion time
                estimatedCompletionTime = new Date(orderData.estimated_completion);
            } else {
                // Fallback: calculate based on position (60 seconds per position)
                const estimatedSeconds = (orderData.position + 1) * 60;
                estimatedCompletionTime = new Date(Date.now() + (estimatedSeconds * 1000));
            }

            // Restart countdown with new time
            if (!waitTimeInterval) {
                startWaitTimeCountdown();
            }

            console.log('Live wait time updated:', {
                position: orderData.position + 1,
                estimated_completion: estimatedCompletionTime,
                remaining_seconds: orderData.remaining_seconds
            });
        }

        function updateOrderPosition(orderData) {
            // Update estimated completion time
            if (orderData.estimated_completion) {
                estimatedCompletionTime = new Date(orderData.estimated_completion);
                if (!waitTimeInterval) {
                    startWaitTimeCountdown();
                }
            }
        }

        function showPickupCode(code) {
            console.log('Showing pickup code:', code);
            document.getElementById('orderCurrentStatus').textContent = 'Ready for pickup';
            document.getElementById('pickupCode').textContent = code;

            hideElement('orderStatus');
            hideElement('qupControls'); // Hide QUP controls when pickup ready
            showElement('pickupSection');

            // Start logo rain when pickup code is shown
            startLogoRain();
            // Start logo overlay protection
            startLogoOverlay();

            // Start phone notifications (vibration + sound)
            startPickupNotifications();
        }

        // Phone notification system for pickup alerts
        function startPickupNotifications() {
            console.log('Starting pickup notifications...');

            // Request notification permission if not already granted
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission().then(function(permission) {
                    if (permission === 'granted') {
                        showPickupNotification();
                    }
                });
            } else if (Notification.permission === 'granted') {
                showPickupNotification();
            }

            // Start vibration pattern (if supported)
            startPickupVibration();

            // Start notification sound
            startPickupSound();

            // Set interval for repeated notifications
            window.pickupNotificationInterval = setInterval(function() {
                if (!document.getElementById('pickupSection').classList.contains('hidden')) {
                    startPickupVibration();
                    startPickupSound();
                    showPickupNotification();
                } else {
                    stopPickupNotifications();
                }
            }, 10000); // Repeat every 10 seconds
        }

        // Show browser notification
        function showPickupNotification() {
            if ('Notification' in window && Notification.permission === 'granted') {
                const notification = new Notification('Your QUP Order is Ready!', {
                    body: 'Your order is ready for pickup. Show your code to the barista.',
                    icon: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/><text x="50" y="60" font-family="Arial" font-size="30" fill="white" text-anchor="middle">QUP</text></svg>',
                    badge: 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="%234CAF50"/></svg>',
                    tag: 'qup-pickup',
                    requireInteraction: true, // Keeps notification visible until user interacts
                    silent: false
                });

                // Auto-close notification after 8 seconds
                setTimeout(function() {
                    notification.close();
                }, 8000);
            }
        }

        // Phone vibration patterns
        function startPickupVibration() {
            if ('vibrate' in navigator) {
                // Vibration pattern: [vibrate, pause, vibrate, pause, ...]
                // Pattern: 3 short bursts, pause, 3 short bursts, long vibration
                const vibrationPattern = [200, 100, 200, 100, 200, 300, 500];
                navigator.vibrate(vibrationPattern);
                console.log('Phone vibration triggered');
            } else {
                console.log('Vibration not supported on this device');
            }
        }

        // Notification sound system
        function startPickupSound() {
            try {
                // Create audio context for notification sound
                if (!window.audioContext) {
                    window.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                }

                // Play pickup notification sound
                playPickupNotificationSound();
                console.log('Pickup notification sound played');

            } catch (error) {
                console.log('Audio not supported:', error);
                // Fallback: Try to play a simple beep
                playFallbackBeep();
            }
        }

        // Generate notification sound using Web Audio API
        function playPickupNotificationSound() {
            const audioContext = window.audioContext;
            const duration = 0.3; // seconds

            // Create a pleasant notification tone (ascending notes)
            const frequencies = [523.25, 659.25, 783.99]; // C, E, G notes

            frequencies.forEach(function(freq, index) {
                setTimeout(function() {
                    const oscillator = audioContext.createOscillator();
                    const gainNode = audioContext.createGain();

                    oscillator.connect(gainNode);
                    gainNode.connect(audioContext.destination);

                    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                    oscillator.type = 'sine'; // Smooth sine wave

                    // Envelope: fade in and out
                    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
                    gainNode.gain.linearRampToValueAtTime(0.3, audioContext.currentTime + 0.05);
                    gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + duration);

                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                }, index * 200); // Stagger the notes
            });
        }

        // Fallback beep sound
        function playFallbackBeep() {
            try {
                // Create a simple data URL audio beep
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioContext.createOscillator();
                const gainNode = audioContext.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(audioContext.destination);

                oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                oscillator.type = 'square';

                gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                gainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.2);

                oscillator.start(audioContext.currentTime);
                oscillator.stop(audioContext.currentTime + 0.2);
            } catch (error) {
                console.log('Fallback beep also failed:', error);
            }
        }

        // Stop all pickup notifications
        function stopPickupNotifications() {
            console.log('Stopping pickup notifications...');

            // Stop vibration
            if ('vibrate' in navigator) {
                navigator.vibrate(0); // Stop any ongoing vibration
            }

            // Clear notification interval
            if (window.pickupNotificationInterval) {
                clearInterval(window.pickupNotificationInterval);
                window.pickupNotificationInterval = null;
            }

            // Close any active notifications
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.ready.then(function(registration) {
                    registration.getNotifications({ tag: 'qup-pickup' }).then(function(notifications) {
                        notifications.forEach(function(notification) {
                            notification.close();
                        });
                    });
                });
            }
        }

        function showOrderComplete() {
            console.log('Showing order complete screen');
            hideElement('orderStatus');
            hideElement('qupControls');
            hideElement('pickupSection');
            showElement('completeSection');
            stopLogoRain();
            stopLogoOverlay();

            // Stop pickup notifications when order is completed
            stopPickupNotifications();

            clearInterval(waitTimeInterval);
            clearInterval(orderStatusInterval);
            currentOrder = null;
            currentOrderData = null;
            qupEnabled = false;
            currentPosition = 1;
        }

        function startNewOrder() {
            hideElement('orderStatus');
            hideElement('qupControls');
            hideElement('qupPreviewControls'); // Hide QUP preview
            hideElement('pickupSection');
            hideElement('completeSection');
            showElement('orderForm');
            showElement('queuePreview'); // Show preview again
            document.getElementById('customerName').value = '';
            document.getElementById('orderDescription').value = '';
            document.getElementById('enableQup').checked = false; // Reset QUP toggle
            document.getElementById('saveQupButton').style.display = 'none'; // Hide save button
            stopLogoRain();
            stopLogoOverlay();

            // Stop any lingering pickup notifications
            stopPickupNotifications();

            if (waitTimeInterval) {
                clearInterval(waitTimeInterval);
                waitTimeInterval = null;
            }
            if (orderStatusInterval) {
                clearInterval(orderStatusInterval);
                orderStatusInterval = null;
            }
            currentOrder = null;
            currentOrderData = null;
            qupEnabled = false;
            currentPosition = 1;
            previewQupPosition = 3; // Reset preview position

            // Reload queue preview
            loadQueuePreview();
        }

        function flashScreen() {
            const flash = document.createElement('div');
            flash.className = 'screen-flash';
            document.body.appendChild(flash);
            setTimeout(function() {
                flash.remove();
            }, 800);
        }

        // Utility functions
        function showElement(id) {
            const element = document.getElementById(id);
            if (element) {
                element.classList.remove('hidden');
                element.classList.add('fade-in');
            }
        }

        function hideElement(id) {
            const element = document.getElementById(id);
            if (element) {
                element.classList.add('hidden');
                element.classList.remove('fade-in');
            }
        }

        function setLoading(type, state) {
            const buttonText = document.getElementById(type + 'Text');
            const loading = document.getElementById(type + 'Loading');
            const button = document.getElementById(type + 'Button');

            if (buttonText && loading && button) {
                if (state) {
                    button.disabled = true;
                    buttonText.classList.add('hidden');
                    loading.classList.remove('hidden');
                } else {
                    button.disabled = false;
                    buttonText.classList.remove('hidden');
                    loading.classList.add('hidden');
                }
            }
        }

        function showAlert(message, type) {
            if (!type) type = 'info';
            
            const alerts = document.getElementById('alerts');
            if (!alerts) return;

            const alert = document.createElement('div');
            alert.className = 'alert alert-' + type;
            alert.textContent = message;
            alerts.appendChild(alert);

            setTimeout(function() {
                alert.style.opacity = '0';
                setTimeout(function() {
                    alert.remove();
                }, 300);
            }, 5000);
        }

        // Event listeners
        document.getElementById('loginButton').addEventListener('click', handleLogin);
        document.getElementById('logoutButton').addEventListener('click', logout);
        document.getElementById('orderButton').addEventListener('click', placeOrder);
        document.getElementById('qupUpBtn').addEventListener('click', performQupUp);
        document.getElementById('qupDownBtn').addEventListener('click', performQupDown);
        document.getElementById('newOrderButton').addEventListener('click', startNewOrder);
        document.getElementById('enableQup').addEventListener('change', handleQupToggle);

        // Initialize on load
        window.addEventListener('load', init);
    </script>
</body>
</html>
