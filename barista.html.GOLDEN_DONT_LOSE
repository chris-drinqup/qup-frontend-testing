<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QUP Barista Dashboard</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #667eea;
            --primary-dark: #4c63d2;
            --secondary: #764ba2;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --info: #3b82f6;
            --bg-primary: #0f0f23;
            --bg-secondary: #1a1a3e;
            --bg-card: #262654;
            --text-primary: #ffffff;
            --text-secondary: #a5a5c9;
            --border: #3a3a6b;
            --shadow: rgba(0, 0, 0, 0.4);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .login-container {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            backdrop-filter: blur(2px);
        }

        .login-form {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            padding: 50px;
            border-radius: 25px;
            width: 450px;
            box-shadow: 0 15px 40px var(--shadow);
            text-align: center;
            border: 1px solid var(--border);
            position: relative;
            transform: translateY(0);
            transition: transform 0.3s ease;
        }

        .login-form:hover {
            transform: translateY(-5px);
            box-shadow: 0 25px 60px var(--shadow);
        }

        .login-form h2 {
            color: var(--text-primary);
            margin-bottom: 35px;
            font-size: 32px;
            font-weight: 800;
            letter-spacing: -0.5px;
        }

        .form-group {
            margin-bottom: 25px;
            text-align: left;
        }

        .form-group label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: var(--text-primary);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .form-group input {
            width: 100%;
            padding: 16px 20px;
            border: 2px solid var(--border);
            border-radius: 15px;
            font-size: 16px;
            background: var(--bg-secondary);
            color: var(--text-primary);
            transition: all 0.3s ease;
            font-family: inherit;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--primary);
            background: var(--bg-card);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .login-btn {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 15px;
            cursor: pointer;
            font-weight: 700;
            font-size: 16px;
            width: 100%;
            margin-top: 15px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .login-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .login-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .dashboard-container {
            display: none;
            margin: 20px;
            min-height: calc(100vh - 40px);
        }

        .container {
            background: var(--bg-card);
            backdrop-filter: blur(20px);
            border-radius: 25px;
            padding: 40px;
            box-shadow: 0 15px 40px var(--shadow);
            max-width: 1400px;
            margin: 0 auto;
            border: 1px solid var(--border);
            position: relative;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border);
            background: var(--bg-secondary);
            padding: 25px;
            border-radius: 20px;
            margin: -10px -10px 30px -10px;
        }

        h2 {
            color: var(--text-primary);
            margin: 0;
            font-size: 32px;
            font-weight: 800;
            letter-spacing: -0.5px;
        }

        .user-info-display {
            background: var(--bg-secondary);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            display: none;
            justify-content: space-between;
            align-items: center;
            border: 1px solid var(--border);
        }

        .user-email {
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .logout-btn-small {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-secondary);
            padding: 6px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .logout-btn-small:hover {
            border-color: var(--danger);
            color: var(--danger);
        }

        .login-form-fields {
            display: block;
        }

        .login-form-fields.hidden {
            display: none;
        }

        .logout-btn {
            background: linear-gradient(45deg, var(--danger), #dc2626);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 12px;
            cursor: pointer;
            font-weight: 700;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: all 0.3s ease;
        }

        .logout-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }

        .datetime-container {
            font-size: 18px;
            margin-bottom: 25px;
            color: var(--text-primary);
            font-weight: 700;
            padding: 25px 30px;
            background: var(--bg-secondary);
            border-radius: 18px;
            border: 1px solid var(--border);
            box-shadow: 0 8px 25px var(--shadow);
            backdrop-filter: blur(10px);
        }

        .status-buttons {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            margin-top: 15px;
        }

        .refresh-btn, .debug-btn, .mass-action-btn, .danger-btn {
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 6px 16px rgba(0,0,0,0.3);
        }

        .refresh-btn {
            background: linear-gradient(135deg, #4caf50 0%, #388e3c 50%, #2e7d32 100%);
        }

        .debug-btn {
            background: linear-gradient(135deg, #9c27b0 0%, #7b1fa2 50%, #6a1b9a 100%);
        }

        .mass-action-btn {
            background: linear-gradient(135deg, #ff9800 0%, #f57c00 50%, #ef6c00 100%);
        }

        .danger-btn {
            background: linear-gradient(135deg, #f44336 0%, #d32f2f 50%, #b71c1c 100%);
        }

        .refresh-btn:hover, .debug-btn:hover, .mass-action-btn:hover, .danger-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 24px rgba(0,0,0,0.4);
        }

        .websocket-status {
            display: inline-block;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 14px;
            font-weight: 600;
            margin-left: 15px;
        }

        .websocket-status.connected {
            background: rgba(16, 185, 129, 0.2);
            color: var(--success);
            border: 1px solid var(--success);
        }

        .websocket-status.disconnected {
            background: rgba(239, 68, 68, 0.2);
            color: var(--danger);
            border: 1px solid var(--danger);
        }

        .websocket-status.connecting {
            background: rgba(251, 191, 36, 0.2);
            color: var(--warning);
            border: 1px solid var(--warning);
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
            border-radius: 18px;
            overflow: hidden;
            box-shadow: 0 15px 40px var(--shadow);
            background: var(--bg-card);
            backdrop-filter: blur(10px);
        }

        .order-table th {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: white;
            text-align: left;
            font-size: 16px;
            padding: 20px 25px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .order-table td {
            padding: 20px 25px;
            text-align: left;
            background-color: var(--bg-secondary);
            font-size: 15px;
            border-bottom: 1px solid var(--border);
            font-weight: 500;
            transition: all 0.3s ease;
        }

        .order-table tr:hover td {
            background-color: var(--bg-card);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.15);
        }

        .order-table button {
            padding: 10px 18px;
            margin: 3px;
            cursor: pointer;
            border: none;
            border-radius: 10px;
            font-weight: 600;
            font-size: 13px;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 0.3px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .order-table button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
        }

        .order-table button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .pickup-code {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #059669;
            background: rgba(209, 250, 229, 0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(5, 150, 105, 0.2);
        }

        .live-timer {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #1976d2;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .order-notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
            z-index: 1000;
            opacity: 0;
            transform: translateX(400px);
            transition: all 0.3s ease;
        }

        .order-notification.show {
            opacity: 1;
            transform: translateX(0);
        }

        .error-message {
            background: rgba(239, 68, 68, 0.15);
            color: var(--danger);
            padding: 18px 25px;
            margin: 15px 0;
            border-radius: 15px;
            border: 1px solid var(--danger);
            font-weight: 600;
            backdrop-filter: blur(10px);
            display: none;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @media (max-width: 768px) {
            .container {
                margin: 10px;
                padding: 25px;
                border-radius: 20px;
            }

            .login-form {
                width: 90%;
                padding: 35px;
                border-radius: 20px;
            }

            .datetime-container {
                font-size: 16px;
                padding: 20px;
            }

            .header {
                flex-direction: column;
                gap: 15px;
                text-align: center;
            }

            h2 {
                font-size: 28px;
            }

            .status-buttons {
                justify-content: center;
            }

            .order-table th,
            .order-table td {
                padding: 15px;
                font-size: 14px;
            }

            .order-table button {
                padding: 8px 14px;
                font-size: 12px;
                margin: 2px;
            }
        }
    </style>
</head>
<body>
    <!-- Login Screen -->
    <div class="login-container" id="loginContainer">
        <div class="login-form">
            <h2>QUP Barista Dashboard</h2>
            <div class="form-group">
                <label for="email">Email:</label>
                <input type="email" id="email" placeholder="Enter your email">
            </div>
            <div class="form-group">
                <label for="password">Password:</label>
                <input type="password" id="password" placeholder="Enter your password">
            </div>
            <button class="login-btn" id="loginButton">
                <span id="loginText">Sign In</span>
                <div id="loginLoading" class="loading" style="display: none;"></div>
            </button>
            <div id="loginError" class="error-message"></div>
        </div>
    </div>

    <!-- Dashboard -->
    <div class="dashboard-container" id="dashboardContainer">
        <div class="container">
            <div class="header">
                <h2>QUP Barista</h2>
                <div style="display: flex; align-items: center;">
                    <span id="userInfo" class="user-info"></span>
                    <span id="websocketStatus" class="websocket-status disconnected">Real-time: OFF</span>
                    <button class="logout-btn" onclick="logout()">Sign Out</button>
                </div>
            </div>
            
            <div id="errorNotification" class="error-message"></div>
            
            <div class="datetime-container">
                <span id="localDateTime"></span> • <span id="queueCounter">0 orders</span> in queue
                <span id="websocketStatus2" class="websocket-status disconnected">WebSocket: Disconnected</span>
                
                <div class="status-buttons">
                    <button class="refresh-btn" onclick="fetchQueue()">Manual Refresh</button>
                    <button class="debug-btn" onclick="debugSystem()">Debug System</button>
                    <button class="mass-action-btn" onclick="finalizeAllOrders()">Finalize All</button>
                    <button class="mass-action-btn" onclick="completeAllOrders()">Complete All</button>
                    <button class="danger-btn" onclick="clearAllOrders()">Clear All</button>
                </div>
            </div>
            
            <table class="order-table">
                <thead>
                    <tr>
                        <th>Order</th>
                        <th>Processing Time</th>
                        <th>PiQUP Code</th>
                        <th style="text-align: center">Actions</th>
                    </tr>
                </thead>
                <tbody id="queueBody">
                    <tr>
                        <td colspan="4" style="text-align:center;">Connecting to real-time updates...</td>
                    </tr>
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Configuration
        const API_BASE = 'https://qupcore-supercode-692478335867.us-central1.run.app';
        const SUPABASE_URL = 'https://eorhgophbjjbiguvkygo.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVvcmhnb3BoYmpqYmlndXZreWdvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg4MjMyMjUsImV4cCI6MjA2NDM5OTIyNX0.fV_6TFXfjDVusTeknF_LAGjxw7BfTZtoQ0helbm5mwo';

        // Initialize Supabase
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // Global state
        let socket = null;
        let currentUser = null;
        let developerKey = null;
        let dateTimeInterval = null;
        let liveTimerInterval = null;
        let isActionInProgress = false;
        let autoRefreshInterval = null;

        // Check if user is already logged in
        async function init() {
            console.log('QUP Barista Dashboard initializing...');
            
            try {
                const { data: { user } } = await supabase.auth.getUser();
                if (user) {
                    showUserInfo(user);
                    showDashboard(user);
                } else {
                    showLogin();
                }
            } catch (error) {
                console.error('Initialization error:', error);
                showLogin();
            }

            // Add event listener for login button
            document.getElementById('loginButton').addEventListener('click', handleLogin);
        }

        function showUserInfo(user) {
            const userInfoSpan = document.getElementById('userInfo');
            if (userInfoSpan) {
                userInfoSpan.textContent = user.email;
                userInfoSpan.style.display = 'inline';
            }
        }

        // Authentication
        async function handleLogin() {
            const email = document.getElementById('email').value.trim();
            const password = document.getElementById('password').value.trim();
            
            if (!email || !password) {
                showError('Please enter both email and password');
                return;
            }
            
            setLoading(true);
            
            try {
                const { data, error } = await supabase.auth.signInWithPassword({
                    email: email,
                    password: password
                });
                
                if (error) throw error;
                
                console.log('Supabase login successful');
                showUserInfo(data.user);
                showDashboard(data.user);
                
            } catch (error) {
                console.error('Login failed:', error);
                showError('Login failed: ' + error.message);
            } finally {
                setLoading(false);
            }
        }

        async function logout() {
            try {
                await supabase.auth.signOut();
                
                // Cleanup
                if (socket) {
                    socket.disconnect();
                    socket = null;
                }
                stopAllIntervals();
                
                currentUser = null;
                developerKey = null;
                
                // Clear form fields
                document.getElementById('email').value = '';
                document.getElementById('password').value = '';
                
                showLogin();
                
            } catch (error) {
                console.error('Logout failed:', error);
            }
        }

        function showLogin() {
            document.getElementById('loginContainer').style.display = 'flex';
            document.getElementById('dashboardContainer').style.display = 'none';
        }

        async function showDashboard(user) {
            currentUser = user;
            
            document.getElementById('loginContainer').style.display = 'none';
            document.getElementById('dashboardContainer').style.display = 'block';
            
            // Get developer key for API access
            await getDeveloperKey();
            
            // Connect WebSocket
            connectWebSocket();
            
            // Start updates
            startTimeUpdates();
            fetchQueue();
            startAutoRefresh();
            
            console.log('Dashboard initialized for:', user.email);
        }

        // Get developer key for API access
        async function getDeveloperKey() {
            try {
                console.log('Getting developer key...');
                
                const response = await fetch(`${API_BASE}/api/auth/developer/login`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        username: 'developer',
                        password: 'dev123'
                    })
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }
                
                const data = await response.json();
                
                if (data.developer_key) {
                    developerKey = data.developer_key;
                    console.log('Developer key obtained');
                } else {
                    throw new Error(data.error || 'No developer key in response');
                }
            } catch (error) {
                console.error('Developer key error:', error);
                
                // Fallback to hardcoded key
                console.log('Using fallback developer key...');
                developerKey = 'UwCNmn3I0XxmJ15nRxu6dkPIqAz46dxOb4ljz0-SRlc';
                console.log('Using fallback developer key');
            }
        }

        // WebSocket connection
        function connectWebSocket() {
            try {
                console.log('Connecting to WebSocket...');
                
                socket = io(API_BASE, {
                    transports: ['websocket', 'polling'],
                    timeout: 20000,
                    reconnection: true,
                    reconnectionDelay: 2000,
                    reconnectionAttempts: 5,
                    forceNew: true
                });

                socket.on('connect', () => {
                    updateWebSocketStatus('connected');
                    console.log('WebSocket connected');
                    
                    // Subscribe to barista events
                    socket.emit('subscribe_barista', { barista: currentUser.email });
                });

                socket.on('disconnect', () => {
                    updateWebSocketStatus('disconnected');
                    console.log('WebSocket disconnected');
                });

                socket.on('connect_error', (error) => {
                    console.error('WebSocket connection error:', error);
                    updateWebSocketStatus('disconnected');
                });

                socket.on('order_update', (data) => {
                    console.log('Order update received:', data);
                    handleOrderUpdate(data);
                });

                socket.on('order_created', (data) => {
                    console.log('New order created:', data);
                    showOrderNotification(`New order: ${data.orderId}`);
                    // Fetch fresh queue data
                    setTimeout(fetchQueue, 500);
                });

                socket.on('queue_update', (data) => {
                    console.log('Queue update received:', data);
                    if (data.queue) {
                        updateQueueTable(data.queue);
                    }
                });

                updateWebSocketStatus('connecting');

            } catch (error) {
                console.error('WebSocket initialization failed:', error);
                updateWebSocketStatus('disconnected');
            }
        }

        function updateWebSocketStatus(status) {
            const statusElements = [
                document.getElementById('websocketStatus'),
                document.getElementById('websocketStatus2')
            ];

            statusElements.forEach(element => {
                if (element) {
                    element.className = `websocket-status ${status}`;
                    switch (status) {
                        case 'connected':
                            element.textContent = 'Real-time: ON';
                            break;
                        case 'connecting':
                            element.textContent = 'Real-time: Connecting...';
                            break;
                        case 'disconnected':
                            element.textContent = 'Real-time: OFF';
                            break;
                    }
                }
            });
        }

        function handleOrderUpdate(data) {
            console.log('Handling order update:', data.action);
            
            // Show notification
            showOrderNotification(`Order ${data.orderId}: ${data.action}`);
            
            // Refresh queue after a short delay
            if (!isActionInProgress) {
                setTimeout(fetchQueue, 1000);
            }
        }

        function showOrderNotification(message) {
            const notification = document.createElement('div');
            notification.className = 'order-notification';
            notification.innerHTML = `<strong>Real-Time Update</strong><br>${message}`;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.classList.add('show');
            }, 100);

            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => {
                    if (document.body.contains(notification)) {
                        document.body.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        // API calls
        async function apiCall(endpoint, options = {}) {
            if (!developerKey) {
                throw new Error('Not authenticated - no developer key available');
            }

            const url = `${API_BASE}${endpoint}`;
            const defaultHeaders = {
                "X-API-Key": developerKey,
                "Content-Type": "application/json"
            };

            const finalOptions = {
                ...options,
                headers: { ...defaultHeaders, ...(options.headers || {}) }
            };

            try {
                console.log(`API Call: ${options.method || 'GET'} ${url}`);
                const response = await fetch(url, finalOptions);
                const data = await response.json();

                if (!response.ok) {
                    throw new Error(data.error || `HTTP ${response.status}: ${response.statusText}`);
                }

                return data;
            } catch (error) {
                console.error(`API call failed for ${endpoint}:`, error);
                throw error;
            }
        }

        async function fetchQueue() {
            if (!developerKey) {
                console.log('Waiting for authentication...');
                return;
            }

            try {
                console.log('Fetching queue data...');
                const data = await apiCall(`/api/v1/queue/list?admin=true&t=${Date.now()}`);

                if (data.status === "success") {
                    console.log(`Queue fetched: ${data.queue?.length || 0} items`);
                    updateQueueTable(data.queue || []);
                    updateQueueCounter(data.queue?.length || 0);
                } else {
                    console.error("Queue fetch failed:", data.message);
                    showError("Failed to fetch queue data");
                }
            } catch (error) {
                console.error("Error fetching queue:", error);
                showError(`Queue fetch error: ${error.message}`);
            }
        }

        function updateQueueTable(queue) {
            const tableBody = document.getElementById("queueBody");
            if (!tableBody) return;

            if (queue.length === 0) {
                tableBody.innerHTML = `
                    <tr>
                        <td colspan="4" style="text-align:center; color: #666; font-style: italic;">
                            No orders in queue
                        </td>
                    </tr>
                `;
                return;
            }

            const html = queue.map(item => {
                if (item.cancelled) return '';

                const orderDisplay = (item.payload?.order) ? item.payload.order : item.id;
                let processingTime = "0:00";
                let pickupCode = "In Progress";
                let actions = '';

                // Calculate processing time
                if (item.timestamp) {
                    const startTime = new Date(item.timestamp);
                    const now = new Date();
                    const elapsedSeconds = Math.floor((now - startTime) / 1000);
                    processingTime = formatDuration(elapsedSeconds);
                }

                if (item.finalized) {
                    // Order is ready for pickup
                    processingTime = "Ready";
                    pickupCode = item.pickup_code || generatePickupCode(item.timestamp);
                    actions = `
                        <button onclick="completeOrder('${item.id}')" style="background: #10b981; color: white;">
                            Complete
                        </button>
                        <button onclick="cancelOrder('${item.id}')" style="background: #ef4444; color: white;">
                            Cancel
                        </button>
                    `;
                } else {
                    // Order is waiting
                    actions = `
                        <button onclick="finalizeOrder('${item.id}')" style="background: #3b82f6; color: white;">
                            PiQUP Ready
                        </button>
                        <button onclick="cancelOrder('${item.id}')" style="background: #ef4444; color: white;">
                            Cancel
                        </button>
                    `;
                }

                const rowStyle = item.finalized ? 'background-color: rgba(209, 250, 229, 0.8);' : '';

                return `
                    <tr style="${rowStyle}" data-order-id="${item.id}" data-start-time="${item.timestamp}">
                        <td>${sanitizeHTML(orderDisplay)}</td>
                        <td><span class="live-timer">${processingTime}</span></td>
                        <td>${item.finalized ? `<span class="pickup-code">${pickupCode}</span>` : pickupCode}</td>
                        <td style="text-align: center">${actions}</td>
                    </tr>
                `;
            }).filter(Boolean).join('');

            tableBody.innerHTML = html || `
                <tr>
                    <td colspan="4" style="text-align:center;">No active orders</td>
                </tr>
            `;
        }

        function updateQueueCounter(count) {
            const counterElement = document.getElementById("queueCounter");
            if (counterElement) {
                counterElement.textContent = `${count} orders`;
            }
        }

        // Order actions
        async function finalizeOrder(orderId) {
            if (isActionInProgress) return;
            
            isActionInProgress = true;
            console.log(`Finalizing order: ${orderId}`);

            try {
                const pickupCode = generatePickupCode();
                
                await apiCall("/api/v1/queue/finalize", {
                    method: "POST",
                    body: JSON.stringify({ 
                        id: orderId, 
                        pickup_code: pickupCode 
                    })
                });

                console.log(`Order ${orderId} finalized with code: ${pickupCode}`);
                showOrderNotification(`Order finalized! Pickup code: ${pickupCode}`);
                
                // Notify customers via WebSocket
                if (socket && socket.connected) {
                    socket.emit('order_finalized', { 
                        orderId: orderId, 
                        pickupCode: pickupCode 
                    });
                }

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Error finalizing order:", error);
                showError(`Failed to finalize order: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        async function completeOrder(orderId) {
            if (isActionInProgress) return;
            
            isActionInProgress = true;
            console.log(`Completing order: ${orderId}`);

            try {
                await apiCall("/api/v1/queue/complete", {
                    method: "POST",
                    body: JSON.stringify({ id: orderId })
                });

                console.log(`Order ${orderId} completed`);
                showOrderNotification(`Order completed: ${orderId}`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Error completing order:", error);
                showError(`Failed to complete order: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        async function cancelOrder(orderId) {
            if (isActionInProgress) return;
            if (!confirm(`Cancel order ${orderId}?`)) return;
            
            isActionInProgress = true;
            console.log(`Cancelling order: ${orderId}`);

            try {
                await apiCall("/api/v1/queue/cancel", {
                    method: "POST",
                    body: JSON.stringify({ id: orderId })
                });

                console.log(`Order ${orderId} cancelled`);
                showOrderNotification(`Order cancelled: ${orderId}`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Error cancelling order:", error);
                showError(`Failed to cancel order: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        // Mass actions
        async function finalizeAllOrders() {
            if (!confirm("Finalize ALL active orders?")) return;
            if (isActionInProgress) return;

            isActionInProgress = true;
            console.log("Finalizing all orders...");

            try {
                const data = await apiCall("/api/v1/queue/list?admin=true");
                const activeOrders = data.queue.filter(item => !item.finalized && !item.cancelled);
                
                let successCount = 0;
                for (const order of activeOrders) {
                    try {
                        const pickupCode = generatePickupCode();
                        await apiCall("/api/v1/queue/finalize", {
                            method: "POST",
                            body: JSON.stringify({ id: order.id, pickup_code: pickupCode })
                        });
                        successCount++;
                        await new Promise(resolve => setTimeout(resolve, 200));
                    } catch (error) {
                        console.warn(`Failed to finalize ${order.id}:`, error);
                    }
                }

                showOrderNotification(`Finalized ${successCount}/${activeOrders.length} orders`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Mass finalize failed:", error);
                showError(`Mass finalize failed: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        async function completeAllOrders() {
            if (!confirm("Complete ALL finalized orders?")) return;
            if (isActionInProgress) return;

            isActionInProgress = true;
            console.log("Completing all orders...");

            try {
                const data = await apiCall("/api/v1/queue/list?admin=true");
                const finalizedOrders = data.queue.filter(item => item.finalized && !item.cancelled);
                
                let successCount = 0;
                for (const order of finalizedOrders) {
                    try {
                        await apiCall("/api/v1/queue/complete", {
                            method: "POST",
                            body: JSON.stringify({ id: order.id })
                        });
                        successCount++;
                        await new Promise(resolve => setTimeout(resolve, 200));
                    } catch (error) {
                        console.warn(`Failed to complete ${order.id}:`, error);
                    }
                }

                showOrderNotification(`Completed ${successCount}/${finalizedOrders.length} orders`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Mass complete failed:", error);
                showError(`Mass complete failed: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        async function clearAllOrders() {
            if (!confirm('Clear all orders? This cannot be undone!')) return;
            if (isActionInProgress) return;

            isActionInProgress = true;
            console.log("Clearing all orders...");

            try {
                const data = await apiCall("/api/v1/queue/list?admin=true");
                
                let successCount = 0;
                for (const order of data.queue) {
                    try {
                        await apiCall("/api/v1/queue/cancel", {
                            method: "POST",
                            body: JSON.stringify({ id: order.id })
                        });
                        successCount++;
                        await new Promise(resolve => setTimeout(resolve, 100));
                    } catch (error) {
                        console.warn(`Failed to clear ${order.id}:`, error);
                    }
                }

                showOrderNotification(`Cleared ${successCount}/${data.queue.length} orders`);

                // Refresh the queue display
                fetchQueue();

            } catch (error) {
                console.error("Clear all failed:", error);
                showError(`Clear all failed: ${error.message}`);
            } finally {
                isActionInProgress = false;
            }
        }

        // Debug functions
        async function debugSystem() {
            console.log("DEBUGGING SYSTEM...");
            
            try {
                const queueData = await apiCall("/api/v1/queue/list?admin=true");
                console.log(`API Queue: ${queueData.queue?.length || 0} orders`);
                console.log("Queue details:", queueData.queue);
                
                const wsStatus = socket?.connected ? 'Connected' : 'Disconnected';
                console.log(`WebSocket: ${wsStatus}`);
                
                alert(`DEBUG RESULTS:\n\nAPI Queue: ${queueData.queue?.length || 0} orders\nWebSocket: ${wsStatus}\nAuth: ${developerKey ? 'OK' : 'MISSING'}\n\nCheck console for detailed logs.`);
                
            } catch (error) {
                console.error("Debug failed:", error);
                alert(`Debug failed: ${error.message}`);
            }
        }

        // Utility functions
        function generatePickupCode(timestamp) {
            const now = timestamp ? new Date(timestamp).getTime() : Date.now();
            return (now % 10000).toString().padStart(4, '0');
        }

        function formatDuration(seconds) {
            const minutes = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${minutes}:${secs.toString().padStart(2, '0')}`;
        }

        function sanitizeHTML(str) {
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function updateDateTime() {
            const now = new Date();
            const formattedTime = now.toLocaleTimeString('en-US', {
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit'
            });
            const dateTimeElement = document.getElementById("localDateTime");
            if (dateTimeElement) {
                dateTimeElement.textContent = formattedTime;
            }
        }

        function updateLiveTimers() {
            const timerElements = document.querySelectorAll('.live-timer');
            timerElements.forEach(timer => {
                const row = timer.closest('tr');
                const startTime = row?.getAttribute('data-start-time');
                if (startTime) {
                    const start = new Date(startTime);
                    const now = new Date();
                    const elapsedSeconds = Math.floor((now - start) / 1000);
                    timer.textContent = formatDuration(elapsedSeconds);
                }
            });
        }

        function startTimeUpdates() {
            stopAllIntervals();
            dateTimeInterval = setInterval(updateDateTime, 1000);
            liveTimerInterval = setInterval(updateLiveTimers, 1000);
        }

        function stopAllIntervals() {
            if (dateTimeInterval) {
                clearInterval(dateTimeInterval);
                dateTimeInterval = null;
            }
            if (liveTimerInterval) {
                clearInterval(liveTimerInterval);
                liveTimerInterval = null;
            }
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
                autoRefreshInterval = null;
            }
        }

        function startAutoRefresh() {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }

            // Auto-refresh queue every 5 seconds to catch new orders
            autoRefreshInterval = setInterval(() => {
                if (!isActionInProgress) {
                    fetchQueue();
                }
            }, 5000);
        }

        function setLoading(loading) {
            const text = document.getElementById('loginText');
            const spinner = document.getElementById('loginLoading');
            const button = text.parentElement;
            
            if (loading) {
                text.style.display = 'none';
                spinner.style.display = 'inline-block';
                button.disabled = true;
            } else {
                text.style.display = 'inline';
                spinner.style.display = 'none';
                button.disabled = false;
            }
        }

        function showError(message) {
            console.error("Error:", message);
            
            const errorDiv = document.getElementById("errorNotification");
            if (errorDiv) {
                errorDiv.innerHTML = `<strong>Error:</strong> ${message}`;
                errorDiv.style.display = "block";
                setTimeout(() => {
                    errorDiv.style.display = "none";
                }, 8000);
            }
            
            // Also show in login screen if visible
            const loginError = document.getElementById("loginError");
            if (loginError && document.getElementById('loginContainer').style.display !== 'none') {
                loginError.innerHTML = `<strong>Error:</strong> ${message}`;
                loginError.style.display = "block";
                setTimeout(() => {
                    loginError.style.display = "none";
                }, 5000);
            }
        }

        // Event listeners
        document.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                const loginContainer = document.getElementById('loginContainer');
                if (loginContainer && loginContainer.style.display !== 'none') {
                    handleLogin();
                }
            }
        });

        // Initialize the app
        document.addEventListener('DOMContentLoaded', init);

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (socket) socket.disconnect();
            stopAllIntervals();
        });
    </script>
</body>
</html>
